// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assets.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
	"server/internal/db/dbtypes"
)

const addAssetToAlbum = `-- name: AddAssetToAlbum :exec
INSERT INTO album_assets (asset_id, album_id, position)
VALUES ($1, $2, $3)
ON CONFLICT (asset_id, album_id) DO NOTHING
`

type AddAssetToAlbumParams struct {
	AssetID  pgtype.UUID `db:"asset_id" json:"asset_id"`
	AlbumID  int32       `db:"album_id" json:"album_id"`
	Position *int32      `db:"position" json:"position"`
}

func (q *Queries) AddAssetToAlbum(ctx context.Context, arg AddAssetToAlbumParams) error {
	_, err := q.db.Exec(ctx, addAssetToAlbum, arg.AssetID, arg.AlbumID, arg.Position)
	return err
}

const addTagToAsset = `-- name: AddTagToAsset :exec
INSERT INTO asset_tags (asset_id, tag_id, confidence, source)
VALUES ($1, $2, $3, $4)
ON CONFLICT (asset_id, tag_id) DO UPDATE
SET confidence = $3, source = $4
`

type AddTagToAssetParams struct {
	AssetID    pgtype.UUID    `db:"asset_id" json:"asset_id"`
	TagID      int32          `db:"tag_id" json:"tag_id"`
	Confidence pgtype.Numeric `db:"confidence" json:"confidence"`
	Source     string         `db:"source" json:"source"`
}

func (q *Queries) AddTagToAsset(ctx context.Context, arg AddTagToAssetParams) error {
	_, err := q.db.Exec(ctx, addTagToAsset,
		arg.AssetID,
		arg.TagID,
		arg.Confidence,
		arg.Source,
	)
	return err
}

const bulkToggleAssetLiked = `-- name: BulkToggleAssetLiked :exec
UPDATE assets
SET liked = NOT liked
WHERE asset_id = ANY($1::uuid[])
  AND is_deleted = false
`

func (q *Queries) BulkToggleAssetLiked(ctx context.Context, assetIds []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, bulkToggleAssetLiked, assetIds)
	return err
}

const bulkUpdateAssetLiked = `-- name: BulkUpdateAssetLiked :exec
UPDATE assets
SET liked = $1::boolean
WHERE asset_id = ANY($2::uuid[])
  AND is_deleted = false
`

type BulkUpdateAssetLikedParams struct {
	Liked    bool          `db:"liked" json:"liked"`
	AssetIds []pgtype.UUID `db:"asset_ids" json:"asset_ids"`
}

func (q *Queries) BulkUpdateAssetLiked(ctx context.Context, arg BulkUpdateAssetLikedParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateAssetLiked, arg.Liked, arg.AssetIds)
	return err
}

const bulkUpdateAssetRating = `-- name: BulkUpdateAssetRating :exec
UPDATE assets
SET rating = $1::integer
WHERE asset_id = ANY($2::uuid[])
  AND is_deleted = false
`

type BulkUpdateAssetRatingParams struct {
	Rating   int32         `db:"rating" json:"rating"`
	AssetIds []pgtype.UUID `db:"asset_ids" json:"asset_ids"`
}

func (q *Queries) BulkUpdateAssetRating(ctx context.Context, arg BulkUpdateAssetRatingParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateAssetRating, arg.Rating, arg.AssetIds)
	return err
}

const countAssetsByRating = `-- name: CountAssetsByRating :many
SELECT rating, COUNT(*) as count
FROM assets
WHERE is_deleted = false
  AND rating IS NOT NULL
  AND ($1::integer IS NULL OR owner_id = $1)
GROUP BY rating
ORDER BY rating DESC
`

type CountAssetsByRatingRow struct {
	Rating *int32 `db:"rating" json:"rating"`
	Count  int64  `db:"count" json:"count"`
}

func (q *Queries) CountAssetsByRating(ctx context.Context, ownerID *int32) ([]CountAssetsByRatingRow, error) {
	rows, err := q.db.Query(ctx, countAssetsByRating, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountAssetsByRatingRow
	for rows.Next() {
		var i CountAssetsByRatingRow
		if err := rows.Scan(&i.Rating, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countLikedAssets = `-- name: CountLikedAssets :one
SELECT COUNT(*) as count
FROM assets
WHERE is_deleted = false
  AND liked = true
  AND ($1::integer IS NULL OR owner_id = $1)
`

func (q *Queries) CountLikedAssets(ctx context.Context, ownerID *int32) (int64, error) {
	row := q.db.QueryRow(ctx, countLikedAssets, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAsset = `-- name: CreateAsset :one
INSERT INTO assets (
    owner_id, type, original_filename, storage_path, mime_type,
    file_size, hash, width, height, duration, taken_time, specific_metadata, rating, liked
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding
`

type CreateAssetParams struct {
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      string                   `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating           *int32                   `db:"rating" json:"rating"`
	Liked            *bool                    `db:"liked" json:"liked"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, createAsset,
		arg.OwnerID,
		arg.Type,
		arg.OriginalFilename,
		arg.StoragePath,
		arg.MimeType,
		arg.FileSize,
		arg.Hash,
		arg.Width,
		arg.Height,
		arg.Duration,
		arg.TakenTime,
		arg.SpecificMetadata,
		arg.Rating,
		arg.Liked,
	)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.Embedding,
	)
	return i, err
}

const createThumbnail = `-- name: CreateThumbnail :one
INSERT INTO thumbnails (asset_id, size, storage_path, mime_type)
VALUES ($1, $2, $3, $4)
RETURNING thumbnail_id, asset_id, size, storage_path, mime_type, created_at
`

type CreateThumbnailParams struct {
	AssetID     pgtype.UUID `db:"asset_id" json:"asset_id"`
	Size        string      `db:"size" json:"size"`
	StoragePath string      `db:"storage_path" json:"storage_path"`
	MimeType    string      `db:"mime_type" json:"mime_type"`
}

func (q *Queries) CreateThumbnail(ctx context.Context, arg CreateThumbnailParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, createThumbnail,
		arg.AssetID,
		arg.Size,
		arg.StoragePath,
		arg.MimeType,
	)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAsset = `-- name: DeleteAsset :exec
UPDATE assets
SET is_deleted = true, deleted_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
`

func (q *Queries) DeleteAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAsset, assetID)
	return err
}

const filterAssets = `-- name: FilterAssets :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.embedding FROM assets a
WHERE a.is_deleted = false
  AND ($1::text IS NULL OR a.type = $1)
  AND ($2::integer IS NULL OR a.owner_id = $2)
  AND ($3::text IS NULL OR
    CASE $4::text
      WHEN 'contains' THEN a.original_filename ILIKE '%' || $3 || '%'
      WHEN 'matches' THEN a.original_filename ILIKE $3
      WHEN 'startswith' THEN a.original_filename ILIKE $3 || '%'
      WHEN 'endswith' THEN a.original_filename ILIKE '%' || $3
      ELSE true
    END
  )
  AND ($5::timestamptz IS NULL OR a.upload_time >= $5)
  AND ($6::timestamptz IS NULL OR a.upload_time <= $6)
  AND ($7::boolean IS NULL OR
    CASE
      WHEN $7 = true THEN (a.specific_metadata->>'is_raw')::boolean = true
      WHEN $7 = false THEN (a.specific_metadata->>'is_raw')::boolean = false OR a.specific_metadata->>'is_raw' IS NULL
      ELSE true
    END
  )
  AND ($8::integer IS NULL OR
    CASE
      WHEN $8 = 0 THEN a.rating IS NULL
      ELSE a.rating = $8
    END
  )
  AND ($9::boolean IS NULL OR a.liked = $9)
  AND ($10::text IS NULL OR a.specific_metadata->>'camera_model' = $10)
  AND ($11::text IS NULL OR a.specific_metadata->>'lens_model' = $11)
ORDER BY a.upload_time DESC
LIMIT $13 OFFSET $12
`

type FilterAssetsParams struct {
	AssetType    *string            `db:"asset_type" json:"asset_type"`
	OwnerID      *int32             `db:"owner_id" json:"owner_id"`
	FilenameVal  *string            `db:"filename_val" json:"filename_val"`
	FilenameMode *string            `db:"filename_mode" json:"filename_mode"`
	DateFrom     pgtype.Timestamptz `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamptz `db:"date_to" json:"date_to"`
	IsRaw        *bool              `db:"is_raw" json:"is_raw"`
	Rating       *int32             `db:"rating" json:"rating"`
	Liked        *bool              `db:"liked" json:"liked"`
	CameraModel  *string            `db:"camera_model" json:"camera_model"`
	LensModel    *string            `db:"lens_model" json:"lens_model"`
	Offset       int32              `db:"offset" json:"offset"`
	Limit        int32              `db:"limit" json:"limit"`
}

func (q *Queries) FilterAssets(ctx context.Context, arg FilterAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, filterAssets,
		arg.AssetType,
		arg.OwnerID,
		arg.FilenameVal,
		arg.FilenameMode,
		arg.DateFrom,
		arg.DateTo,
		arg.IsRaw,
		arg.Rating,
		arg.Liked,
		arg.CameraModel,
		arg.LensModel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetByID = `-- name: GetAssetByID :one
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE asset_id = $1 AND is_deleted = false
`

func (q *Queries) GetAssetByID(ctx context.Context, assetID pgtype.UUID) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByID, assetID)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.Embedding,
	)
	return i, err
}

const getAssetStatsForOwner = `-- name: GetAssetStatsForOwner :one
SELECT
  COUNT(*) as total_assets,
  COUNT(CASE WHEN liked = true THEN 1 END) as liked_count,
  COUNT(CASE WHEN rating IS NOT NULL THEN 1 END) as rated_count,
  AVG(rating) as avg_rating,
  MAX(rating) as max_rating,
  MIN(rating) as min_rating
FROM assets
WHERE is_deleted = false
  AND owner_id = $1::integer
`

type GetAssetStatsForOwnerRow struct {
	TotalAssets int64       `db:"total_assets" json:"total_assets"`
	LikedCount  int64       `db:"liked_count" json:"liked_count"`
	RatedCount  int64       `db:"rated_count" json:"rated_count"`
	AvgRating   float64     `db:"avg_rating" json:"avg_rating"`
	MaxRating   interface{} `db:"max_rating" json:"max_rating"`
	MinRating   interface{} `db:"min_rating" json:"min_rating"`
}

func (q *Queries) GetAssetStatsForOwner(ctx context.Context, ownerID int32) (GetAssetStatsForOwnerRow, error) {
	row := q.db.QueryRow(ctx, getAssetStatsForOwner, ownerID)
	var i GetAssetStatsForOwnerRow
	err := row.Scan(
		&i.TotalAssets,
		&i.LikedCount,
		&i.RatedCount,
		&i.AvgRating,
		&i.MaxRating,
		&i.MinRating,
	)
	return i, err
}

const getAssetsByHash = `-- name: GetAssetsByHash :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE hash = $1 AND is_deleted = false
`

func (q *Queries) GetAssetsByHash(ctx context.Context, hash *string) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByHash, hash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByOwner = `-- name: GetAssetsByOwner :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE owner_id = $1 AND is_deleted = false
ORDER BY upload_time DESC
LIMIT $2 OFFSET $3
`

type GetAssetsByOwnerParams struct {
	OwnerID *int32 `db:"owner_id" json:"owner_id"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAssetsByOwner(ctx context.Context, arg GetAssetsByOwnerParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByOwnerAndTypesSorted = `-- name: GetAssetsByOwnerAndTypesSorted :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE owner_id = $1 AND type = ANY($2::text[]) AND is_deleted = false
ORDER BY
  CASE WHEN $3 = 'asc' THEN COALESCE(taken_time, upload_time) END ASC,
  CASE WHEN $3 = 'desc' THEN COALESCE(taken_time, upload_time) END DESC
LIMIT $5 OFFSET $4
`

type GetAssetsByOwnerAndTypesSortedParams struct {
	OwnerID   *int32      `db:"owner_id" json:"owner_id"`
	Types     []string    `db:"types" json:"types"`
	SortOrder interface{} `db:"sort_order" json:"sort_order"`
	Offset    int32       `db:"offset" json:"offset"`
	Limit     int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetAssetsByOwnerAndTypesSorted(ctx context.Context, arg GetAssetsByOwnerAndTypesSortedParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByOwnerAndTypesSorted,
		arg.OwnerID,
		arg.Types,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByOwnerSorted = `-- name: GetAssetsByOwnerSorted :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE owner_id = $1 AND is_deleted = false
ORDER BY
  CASE WHEN $2 = 'asc' THEN COALESCE(taken_time, upload_time) END ASC,
  CASE WHEN $2 = 'desc' THEN COALESCE(taken_time, upload_time) END DESC
LIMIT $3 OFFSET $4
`

type GetAssetsByOwnerSortedParams struct {
	OwnerID *int32      `db:"owner_id" json:"owner_id"`
	Column2 interface{} `db:"column_2" json:"column_2"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

func (q *Queries) GetAssetsByOwnerSorted(ctx context.Context, arg GetAssetsByOwnerSortedParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByOwnerSorted,
		arg.OwnerID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByOwnerWithRatingLiked = `-- name: GetAssetsByOwnerWithRatingLiked :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE owner_id = $1::integer
  AND is_deleted = false
  AND ($2::boolean IS NULL OR
       ($2 = true AND rating IS NOT NULL) OR
       ($2 = false AND rating IS NULL))
  AND ($3::boolean IS NULL OR liked = $3)
ORDER BY
  CASE WHEN $4 = 'rating' THEN rating END DESC NULLS LAST,
  CASE WHEN $4 = 'upload_time' THEN upload_time END DESC,
  CASE WHEN $4 = 'taken_time' THEN COALESCE(taken_time, upload_time) END DESC
LIMIT $6 OFFSET $5
`

type GetAssetsByOwnerWithRatingLikedParams struct {
	OwnerID   int32       `db:"owner_id" json:"owner_id"`
	HasRating *bool       `db:"has_rating" json:"has_rating"`
	IsLiked   *bool       `db:"is_liked" json:"is_liked"`
	SortBy    interface{} `db:"sort_by" json:"sort_by"`
	Offset    int32       `db:"offset" json:"offset"`
	Limit     int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetAssetsByOwnerWithRatingLiked(ctx context.Context, arg GetAssetsByOwnerWithRatingLikedParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByOwnerWithRatingLiked,
		arg.OwnerID,
		arg.HasRating,
		arg.IsLiked,
		arg.SortBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByRating = `-- name: GetAssetsByRating :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
  AND rating = $1::integer
ORDER BY upload_time DESC
LIMIT $3 OFFSET $2
`

type GetAssetsByRatingParams struct {
	Rating int32 `db:"rating" json:"rating"`
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetAssetsByRating(ctx context.Context, arg GetAssetsByRatingParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByRating, arg.Rating, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByRatingAndType = `-- name: GetAssetsByRatingAndType :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
  AND rating = $1::integer
  AND type = $2::text
  AND ($3::integer IS NULL OR owner_id = $3)
ORDER BY upload_time DESC
LIMIT $5 OFFSET $4
`

type GetAssetsByRatingAndTypeParams struct {
	Rating    int32  `db:"rating" json:"rating"`
	AssetType string `db:"asset_type" json:"asset_type"`
	OwnerID   *int32 `db:"owner_id" json:"owner_id"`
	Offset    int32  `db:"offset" json:"offset"`
	Limit     int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetAssetsByRatingAndType(ctx context.Context, arg GetAssetsByRatingAndTypeParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByRatingAndType,
		arg.Rating,
		arg.AssetType,
		arg.OwnerID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByRatingRange = `-- name: GetAssetsByRatingRange :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
  AND rating IS NOT NULL
  AND rating >= $1::integer
  AND rating <= $2::integer
  AND ($3::integer IS NULL OR owner_id = $3)
ORDER BY rating DESC, upload_time DESC
LIMIT $5 OFFSET $4
`

type GetAssetsByRatingRangeParams struct {
	MinRating int32  `db:"min_rating" json:"min_rating"`
	MaxRating int32  `db:"max_rating" json:"max_rating"`
	OwnerID   *int32 `db:"owner_id" json:"owner_id"`
	Offset    int32  `db:"offset" json:"offset"`
	Limit     int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetAssetsByRatingRange(ctx context.Context, arg GetAssetsByRatingRangeParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByRatingRange,
		arg.MinRating,
		arg.MaxRating,
		arg.OwnerID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByType = `-- name: GetAssetsByType :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE type = $1 AND is_deleted = false
ORDER BY upload_time DESC
LIMIT $2 OFFSET $3
`

type GetAssetsByTypeParams struct {
	Type   string `db:"type" json:"type"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAssetsByType(ctx context.Context, arg GetAssetsByTypeParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByTypesSorted = `-- name: GetAssetsByTypesSorted :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE type = ANY($1::text[]) AND is_deleted = false
ORDER BY
  CASE WHEN $2 = 'asc' THEN COALESCE(taken_time, upload_time) END ASC,
  CASE WHEN $2 = 'desc' THEN COALESCE(taken_time, upload_time) END DESC
LIMIT $4 OFFSET $3
`

type GetAssetsByTypesSortedParams struct {
	Types     []string    `db:"types" json:"types"`
	SortOrder interface{} `db:"sort_order" json:"sort_order"`
	Offset    int32       `db:"offset" json:"offset"`
	Limit     int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetAssetsByTypesSorted(ctx context.Context, arg GetAssetsByTypesSortedParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByTypesSorted,
		arg.Types,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctCameraMakes = `-- name: GetDistinctCameraMakes :many
SELECT DISTINCT a.specific_metadata->>'camera_model' as camera_model
FROM assets a
WHERE a.is_deleted = false
  AND a.specific_metadata->>'camera_model' IS NOT NULL
  AND a.specific_metadata->>'camera_model' != ''
ORDER BY camera_model
`

func (q *Queries) GetDistinctCameraMakes(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getDistinctCameraMakes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var camera_model interface{}
		if err := rows.Scan(&camera_model); err != nil {
			return nil, err
		}
		items = append(items, camera_model)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctLenses = `-- name: GetDistinctLenses :many
SELECT DISTINCT a.specific_metadata->>'lens_model' as lens_model
FROM assets a
WHERE a.is_deleted = false
  AND a.specific_metadata->>'lens_model' IS NOT NULL
  AND a.specific_metadata->>'lens_model' != ''
ORDER BY lens_model
`

func (q *Queries) GetDistinctLenses(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getDistinctLenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var lens_model interface{}
		if err := rows.Scan(&lens_model); err != nil {
			return nil, err
		}
		items = append(items, lens_model)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedAssets = `-- name: GetLikedAssets :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
  AND liked = true
ORDER BY upload_time DESC
LIMIT $2 OFFSET $1
`

type GetLikedAssetsParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetLikedAssets(ctx context.Context, arg GetLikedAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getLikedAssets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedAssetsByOwner = `-- name: GetLikedAssetsByOwner :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
  AND liked = true
  AND owner_id = $1::integer
ORDER BY upload_time DESC
LIMIT $3 OFFSET $2
`

type GetLikedAssetsByOwnerParams struct {
	OwnerID int32 `db:"owner_id" json:"owner_id"`
	Offset  int32 `db:"offset" json:"offset"`
	Limit   int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetLikedAssetsByOwner(ctx context.Context, arg GetLikedAssetsByOwnerParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getLikedAssetsByOwner, arg.OwnerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedAssetsByType = `-- name: GetLikedAssetsByType :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
  AND liked = true
  AND type = $1::text
  AND ($2::integer IS NULL OR owner_id = $2)
ORDER BY upload_time DESC
LIMIT $4 OFFSET $3
`

type GetLikedAssetsByTypeParams struct {
	AssetType string `db:"asset_type" json:"asset_type"`
	OwnerID   *int32 `db:"owner_id" json:"owner_id"`
	Offset    int32  `db:"offset" json:"offset"`
	Limit     int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetLikedAssetsByType(ctx context.Context, arg GetLikedAssetsByTypeParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getLikedAssetsByType,
		arg.AssetType,
		arg.OwnerID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThumbnailByAssetAndSize = `-- name: GetThumbnailByAssetAndSize :one
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails
WHERE asset_id = $1 AND size = $2
`

type GetThumbnailByAssetAndSizeParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	Size    string      `db:"size" json:"size"`
}

func (q *Queries) GetThumbnailByAssetAndSize(ctx context.Context, arg GetThumbnailByAssetAndSizeParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, getThumbnailByAssetAndSize, arg.AssetID, arg.Size)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const getThumbnailByID = `-- name: GetThumbnailByID :one
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails WHERE thumbnail_id = $1
`

func (q *Queries) GetThumbnailByID(ctx context.Context, thumbnailID int32) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, getThumbnailByID, thumbnailID)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const getThumbnailsByAsset = `-- name: GetThumbnailsByAsset :many
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails
WHERE asset_id = $1
ORDER BY CASE size
    WHEN 'small' THEN 1
    WHEN 'medium' THEN 2
    WHEN 'large' THEN 3
END, thumbnail_id
`

func (q *Queries) GetThumbnailsByAsset(ctx context.Context, assetID pgtype.UUID) ([]Thumbnail, error) {
	rows, err := q.db.Query(ctx, getThumbnailsByAsset, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thumbnail
	for rows.Next() {
		var i Thumbnail
		if err := rows.Scan(
			&i.ThumbnailID,
			&i.AssetID,
			&i.Size,
			&i.StoragePath,
			&i.MimeType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRatedAssets = `-- name: GetTopRatedAssets :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
  AND rating IS NOT NULL
  AND rating >= $1::integer
  AND ($2::integer IS NULL OR owner_id = $2)
ORDER BY rating DESC, upload_time DESC
LIMIT $4 OFFSET $3
`

type GetTopRatedAssetsParams struct {
	MinRating int32  `db:"min_rating" json:"min_rating"`
	OwnerID   *int32 `db:"owner_id" json:"owner_id"`
	Offset    int32  `db:"offset" json:"offset"`
	Limit     int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetTopRatedAssets(ctx context.Context, arg GetTopRatedAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getTopRatedAssets,
		arg.MinRating,
		arg.OwnerID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAssetFromAlbum = `-- name: RemoveAssetFromAlbum :exec
DELETE FROM album_assets
WHERE asset_id = $1 AND album_id = $2
`

type RemoveAssetFromAlbumParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	AlbumID int32       `db:"album_id" json:"album_id"`
}

func (q *Queries) RemoveAssetFromAlbum(ctx context.Context, arg RemoveAssetFromAlbumParams) error {
	_, err := q.db.Exec(ctx, removeAssetFromAlbum, arg.AssetID, arg.AlbumID)
	return err
}

const removeTagFromAsset = `-- name: RemoveTagFromAsset :exec
DELETE FROM asset_tags
WHERE asset_id = $1 AND tag_id = $2
`

type RemoveTagFromAssetParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	TagID   int32       `db:"tag_id" json:"tag_id"`
}

func (q *Queries) RemoveTagFromAsset(ctx context.Context, arg RemoveTagFromAssetParams) error {
	_, err := q.db.Exec(ctx, removeTagFromAsset, arg.AssetID, arg.TagID)
	return err
}

const searchAssets = `-- name: SearchAssets :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding FROM assets
WHERE is_deleted = false
AND ($1::text IS NULL OR original_filename ILIKE '%' || $1 || '%')
AND ($2::text IS NULL OR type = $2)
ORDER BY upload_time DESC
LIMIT $3 OFFSET $4
`

type SearchAssetsParams struct {
	Column1 string `db:"column_1" json:"column_1"`
	Column2 string `db:"column_2" json:"column_2"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchAssets(ctx context.Context, arg SearchAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssets,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsFilename = `-- name: SearchAssetsFilename :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.embedding FROM assets a
WHERE a.is_deleted = false
  AND a.original_filename ILIKE '%' || $1 || '%'
  AND ($2::text IS NULL OR a.type = $2)
  AND ($3::integer IS NULL OR a.owner_id = $3)
  AND ($4::text IS NULL OR
    CASE $5::text
      WHEN 'contains' THEN a.original_filename ILIKE '%' || $4 || '%'
      WHEN 'matches' THEN a.original_filename ILIKE $4
      WHEN 'startswith' THEN a.original_filename ILIKE $4 || '%'
      WHEN 'endswith' THEN a.original_filename ILIKE '%' || $4
      ELSE true
    END
  )
  AND ($6::timestamptz IS NULL OR a.upload_time >= $6)
  AND ($7::timestamptz IS NULL OR a.upload_time <= $7)
  AND ($8::boolean IS NULL OR
    CASE
      WHEN $8 = true THEN (a.specific_metadata->>'is_raw')::boolean = true
      WHEN $8 = false THEN (a.specific_metadata->>'is_raw')::boolean = false OR a.specific_metadata->>'is_raw' IS NULL
      ELSE true
    END
  )
  AND ($9::integer IS NULL OR
    CASE
      WHEN $9 = 0 THEN a.rating IS NULL
      ELSE a.rating = $9
    END
  )
  AND ($10::boolean IS NULL OR a.liked = $10)
  AND ($11::text IS NULL OR a.specific_metadata->>'camera_model' = $11)
  AND ($12::text IS NULL OR a.specific_metadata->>'lens_model' = $12)
ORDER BY a.upload_time DESC
LIMIT $14 OFFSET $13
`

type SearchAssetsFilenameParams struct {
	Query        *string            `db:"query" json:"query"`
	AssetType    *string            `db:"asset_type" json:"asset_type"`
	OwnerID      *int32             `db:"owner_id" json:"owner_id"`
	FilenameVal  *string            `db:"filename_val" json:"filename_val"`
	FilenameMode *string            `db:"filename_mode" json:"filename_mode"`
	DateFrom     pgtype.Timestamptz `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamptz `db:"date_to" json:"date_to"`
	IsRaw        *bool              `db:"is_raw" json:"is_raw"`
	Rating       *int32             `db:"rating" json:"rating"`
	Liked        *bool              `db:"liked" json:"liked"`
	CameraModel  *string            `db:"camera_model" json:"camera_model"`
	LensModel    *string            `db:"lens_model" json:"lens_model"`
	Offset       int32              `db:"offset" json:"offset"`
	Limit        int32              `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsFilename(ctx context.Context, arg SearchAssetsFilenameParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsFilename,
		arg.Query,
		arg.AssetType,
		arg.OwnerID,
		arg.FilenameVal,
		arg.FilenameMode,
		arg.DateFrom,
		arg.DateTo,
		arg.IsRaw,
		arg.Rating,
		arg.Liked,
		arg.CameraModel,
		arg.LensModel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsVector = `-- name: SearchAssetsVector :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.embedding, (a.embedding <-> $1::vector) AS distance FROM assets a
WHERE a.is_deleted = false
  AND a.embedding IS NOT NULL
  AND ($2::text IS NULL OR a.type = $2)
  AND ($3::integer IS NULL OR a.owner_id = $3)
  AND ($4::text IS NULL OR
    CASE $5::text
      WHEN 'contains' THEN a.original_filename ILIKE '%' || $4 || '%'
      WHEN 'matches' THEN a.original_filename ILIKE $4
      WHEN 'startswith' THEN a.original_filename ILIKE $4 || '%'
      WHEN 'endswith' THEN a.original_filename ILIKE '%' || $4
      ELSE true
    END
  )
  AND ($6::timestamptz IS NULL OR a.upload_time >= $6)
  AND ($7::timestamptz IS NULL OR a.upload_time <= $7)
  AND ($8::boolean IS NULL OR
    CASE
      WHEN $8 = true THEN (a.specific_metadata->>'is_raw')::boolean = true
      WHEN $8 = false THEN (a.specific_metadata->>'is_raw')::boolean = false OR a.specific_metadata->>'is_raw' IS NULL
      ELSE true
    END
  )
  AND ($9::integer IS NULL OR
    CASE
      WHEN $9 = 0 THEN a.rating IS NULL
      ELSE a.rating = $9
    END
  )
  AND ($10::boolean IS NULL OR a.liked = $10)
  AND ($11::text IS NULL OR a.specific_metadata->>'camera_model' = $11)
  AND ($12::text IS NULL OR a.specific_metadata->>'lens_model' = $12)
ORDER BY (a.embedding <-> $1::vector)
LIMIT $14 OFFSET $13
`

type SearchAssetsVectorParams struct {
	Embedding    pgvector_go.Vector `db:"embedding" json:"embedding"`
	AssetType    *string            `db:"asset_type" json:"asset_type"`
	OwnerID      *int32             `db:"owner_id" json:"owner_id"`
	FilenameVal  *string            `db:"filename_val" json:"filename_val"`
	FilenameMode *string            `db:"filename_mode" json:"filename_mode"`
	DateFrom     pgtype.Timestamptz `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamptz `db:"date_to" json:"date_to"`
	IsRaw        *bool              `db:"is_raw" json:"is_raw"`
	Rating       *int32             `db:"rating" json:"rating"`
	Liked        *bool              `db:"liked" json:"liked"`
	CameraModel  *string            `db:"camera_model" json:"camera_model"`
	LensModel    *string            `db:"lens_model" json:"lens_model"`
	Offset       int32              `db:"offset" json:"offset"`
	Limit        int32              `db:"limit" json:"limit"`
}

type SearchAssetsVectorRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      string                   `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating           *int32                   `db:"rating" json:"rating"`
	Liked            *bool                    `db:"liked" json:"liked"`
	Embedding        *pgvector_go.Vector      `db:"embedding" json:"embedding"`
	Distance         interface{}              `db:"distance" json:"distance"`
}

func (q *Queries) SearchAssetsVector(ctx context.Context, arg SearchAssetsVectorParams) ([]SearchAssetsVectorRow, error) {
	rows, err := q.db.Query(ctx, searchAssetsVector,
		arg.Embedding,
		arg.AssetType,
		arg.OwnerID,
		arg.FilenameVal,
		arg.FilenameMode,
		arg.DateFrom,
		arg.DateTo,
		arg.IsRaw,
		arg.Rating,
		arg.Liked,
		arg.CameraModel,
		arg.LensModel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAssetsVectorRow
	for rows.Next() {
		var i SearchAssetsVectorRow
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.Embedding,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE assets
SET original_filename = $2, specific_metadata = $3, updated_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
RETURNING asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, taken_time, is_deleted, deleted_at, specific_metadata, rating, liked, embedding
`

type UpdateAssetParams struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, updateAsset, arg.AssetID, arg.OriginalFilename, arg.SpecificMetadata)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.Embedding,
	)
	return i, err
}

const updateAssetDescription = `-- name: UpdateAssetDescription :exec
UPDATE assets
SET specific_metadata = jsonb_set(
    COALESCE(specific_metadata, '{}'::jsonb),
    '{description}',
    to_jsonb($1::text)
)
WHERE asset_id = $2
`

type UpdateAssetDescriptionParams struct {
	Description string      `db:"description" json:"description"`
	AssetID     pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetDescription(ctx context.Context, arg UpdateAssetDescriptionParams) error {
	_, err := q.db.Exec(ctx, updateAssetDescription, arg.Description, arg.AssetID)
	return err
}

const updateAssetDimensions = `-- name: UpdateAssetDimensions :exec
UPDATE assets
SET width = $2, height = $3
WHERE asset_id = $1
`

type UpdateAssetDimensionsParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	Width   *int32      `db:"width" json:"width"`
	Height  *int32      `db:"height" json:"height"`
}

func (q *Queries) UpdateAssetDimensions(ctx context.Context, arg UpdateAssetDimensionsParams) error {
	_, err := q.db.Exec(ctx, updateAssetDimensions, arg.AssetID, arg.Width, arg.Height)
	return err
}

const updateAssetDuration = `-- name: UpdateAssetDuration :exec
UPDATE assets
SET duration = $2
WHERE asset_id = $1
`

type UpdateAssetDurationParams struct {
	AssetID  pgtype.UUID `db:"asset_id" json:"asset_id"`
	Duration *float64    `db:"duration" json:"duration"`
}

func (q *Queries) UpdateAssetDuration(ctx context.Context, arg UpdateAssetDurationParams) error {
	_, err := q.db.Exec(ctx, updateAssetDuration, arg.AssetID, arg.Duration)
	return err
}

const updateAssetLike = `-- name: UpdateAssetLike :exec
UPDATE assets
SET liked = $1::boolean
WHERE asset_id = $2
`

type UpdateAssetLikeParams struct {
	Liked   bool        `db:"liked" json:"liked"`
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetLike(ctx context.Context, arg UpdateAssetLikeParams) error {
	_, err := q.db.Exec(ctx, updateAssetLike, arg.Liked, arg.AssetID)
	return err
}

const updateAssetMetadata = `-- name: UpdateAssetMetadata :exec
UPDATE assets
SET specific_metadata = $2
WHERE asset_id = $1
`

type UpdateAssetMetadataParams struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) UpdateAssetMetadata(ctx context.Context, arg UpdateAssetMetadataParams) error {
	_, err := q.db.Exec(ctx, updateAssetMetadata, arg.AssetID, arg.SpecificMetadata)
	return err
}

const updateAssetMetadataWithTakenTime = `-- name: UpdateAssetMetadataWithTakenTime :exec
UPDATE assets
SET specific_metadata = $1,
    taken_time = CASE
        WHEN $2::timestamptz IS NOT NULL THEN $2::timestamptz
        ELSE COALESCE(taken_time, upload_time)
    END
WHERE asset_id = $3
`

type UpdateAssetMetadataWithTakenTimeParams struct {
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetMetadataWithTakenTime(ctx context.Context, arg UpdateAssetMetadataWithTakenTimeParams) error {
	_, err := q.db.Exec(ctx, updateAssetMetadataWithTakenTime, arg.SpecificMetadata, arg.TakenTime, arg.AssetID)
	return err
}

const updateAssetRating = `-- name: UpdateAssetRating :exec
UPDATE assets
SET rating = $1::integer
WHERE asset_id = $2
`

type UpdateAssetRatingParams struct {
	Rating  int32       `db:"rating" json:"rating"`
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetRating(ctx context.Context, arg UpdateAssetRatingParams) error {
	_, err := q.db.Exec(ctx, updateAssetRating, arg.Rating, arg.AssetID)
	return err
}

const updateAssetRatingAndLike = `-- name: UpdateAssetRatingAndLike :exec
UPDATE assets
SET rating = $1::integer,
    liked = $2::boolean
WHERE asset_id = $3
`

type UpdateAssetRatingAndLikeParams struct {
	Rating  int32       `db:"rating" json:"rating"`
	Liked   bool        `db:"liked" json:"liked"`
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetRatingAndLike(ctx context.Context, arg UpdateAssetRatingAndLikeParams) error {
	_, err := q.db.Exec(ctx, updateAssetRatingAndLike, arg.Rating, arg.Liked, arg.AssetID)
	return err
}
