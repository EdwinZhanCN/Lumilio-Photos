// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assets.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
	"server/internal/db/dbtypes"
)

const addAssetToAlbum = `-- name: AddAssetToAlbum :exec
INSERT INTO album_assets (asset_id, album_id, position)
VALUES ($1, $2, $3)
ON CONFLICT (asset_id, album_id) DO NOTHING
`

type AddAssetToAlbumParams struct {
	AssetID  pgtype.UUID `db:"asset_id" json:"asset_id"`
	AlbumID  int32       `db:"album_id" json:"album_id"`
	Position *int32      `db:"position" json:"position"`
}

func (q *Queries) AddAssetToAlbum(ctx context.Context, arg AddAssetToAlbumParams) error {
	_, err := q.db.Exec(ctx, addAssetToAlbum, arg.AssetID, arg.AlbumID, arg.Position)
	return err
}

const addTagToAsset = `-- name: AddTagToAsset :exec
INSERT INTO asset_tags (asset_id, tag_id, confidence, source)
VALUES ($1, $2, $3, $4)
ON CONFLICT (asset_id, tag_id) DO UPDATE
SET confidence = $3, source = $4
`

type AddTagToAssetParams struct {
	AssetID    pgtype.UUID    `db:"asset_id" json:"asset_id"`
	TagID      int32          `db:"tag_id" json:"tag_id"`
	Confidence pgtype.Numeric `db:"confidence" json:"confidence"`
	Source     string         `db:"source" json:"source"`
}

func (q *Queries) AddTagToAsset(ctx context.Context, arg AddTagToAssetParams) error {
	_, err := q.db.Exec(ctx, addTagToAsset,
		arg.AssetID,
		arg.TagID,
		arg.Confidence,
		arg.Source,
	)
	return err
}

const createAsset = `-- name: CreateAsset :one
INSERT INTO assets (
    owner_id, type, original_filename, storage_path, mime_type,
    file_size, hash, width, height, duration, specific_metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding
`

type CreateAssetParams struct {
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      string                   `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, createAsset,
		arg.OwnerID,
		arg.Type,
		arg.OriginalFilename,
		arg.StoragePath,
		arg.MimeType,
		arg.FileSize,
		arg.Hash,
		arg.Width,
		arg.Height,
		arg.Duration,
		arg.SpecificMetadata,
	)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Embedding,
	)
	return i, err
}

const createThumbnail = `-- name: CreateThumbnail :one
INSERT INTO thumbnails (asset_id, size, storage_path, mime_type)
VALUES ($1, $2, $3, $4)
RETURNING thumbnail_id, asset_id, size, storage_path, mime_type, created_at
`

type CreateThumbnailParams struct {
	AssetID     pgtype.UUID `db:"asset_id" json:"asset_id"`
	Size        string      `db:"size" json:"size"`
	StoragePath string      `db:"storage_path" json:"storage_path"`
	MimeType    string      `db:"mime_type" json:"mime_type"`
}

func (q *Queries) CreateThumbnail(ctx context.Context, arg CreateThumbnailParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, createThumbnail,
		arg.AssetID,
		arg.Size,
		arg.StoragePath,
		arg.MimeType,
	)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAsset = `-- name: DeleteAsset :exec
UPDATE assets
SET is_deleted = true, deleted_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
`

func (q *Queries) DeleteAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAsset, assetID)
	return err
}

const filterAssets = `-- name: FilterAssets :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.embedding FROM assets a
WHERE a.is_deleted = false
  AND ($1::text IS NULL OR a.type = $1)
  AND ($2::integer IS NULL OR a.owner_id = $2)
  AND ($3::text IS NULL OR
    CASE $4::text
      WHEN 'contains' THEN a.original_filename ILIKE '%' || $3 || '%'
      WHEN 'matches' THEN a.original_filename ILIKE $3
      WHEN 'startswith' THEN a.original_filename ILIKE $3 || '%'
      WHEN 'endswith' THEN a.original_filename ILIKE '%' || $3
      ELSE true
    END
  )
  AND ($5::timestamptz IS NULL OR a.upload_time >= $5)
  AND ($6::timestamptz IS NULL OR a.upload_time <= $6)
  AND ($7::boolean IS NULL OR
    CASE
      WHEN $7 = true THEN (a.specific_metadata->>'is_raw')::boolean = true
      WHEN $7 = false THEN (a.specific_metadata->>'is_raw')::boolean = false OR a.specific_metadata->>'is_raw' IS NULL
      ELSE true
    END
  )
  AND ($8::integer IS NULL OR
    CASE
      WHEN $8 = 0 THEN a.specific_metadata->>'rating' IS NULL
      ELSE (a.specific_metadata->>'rating')::integer = $8
    END
  )
  AND ($9::boolean IS NULL OR (a.specific_metadata->>'liked')::boolean = $9)
  AND ($10::text IS NULL OR a.specific_metadata->>'camera_model' = $10)
  AND ($11::text IS NULL OR a.specific_metadata->>'lens_model' = $11)
ORDER BY a.upload_time DESC
LIMIT $13 OFFSET $12
`

type FilterAssetsParams struct {
	AssetType    *string            `db:"asset_type" json:"asset_type"`
	OwnerID      *int32             `db:"owner_id" json:"owner_id"`
	FilenameVal  *string            `db:"filename_val" json:"filename_val"`
	FilenameMode *string            `db:"filename_mode" json:"filename_mode"`
	DateFrom     pgtype.Timestamptz `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamptz `db:"date_to" json:"date_to"`
	IsRaw        *bool              `db:"is_raw" json:"is_raw"`
	Rating       *int32             `db:"rating" json:"rating"`
	Liked        *bool              `db:"liked" json:"liked"`
	CameraModel  *string            `db:"camera_model" json:"camera_model"`
	LensModel    *string            `db:"lens_model" json:"lens_model"`
	Offset       int32              `db:"offset" json:"offset"`
	Limit        int32              `db:"limit" json:"limit"`
}

func (q *Queries) FilterAssets(ctx context.Context, arg FilterAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, filterAssets,
		arg.AssetType,
		arg.OwnerID,
		arg.FilenameVal,
		arg.FilenameMode,
		arg.DateFrom,
		arg.DateTo,
		arg.IsRaw,
		arg.Rating,
		arg.Liked,
		arg.CameraModel,
		arg.LensModel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetByID = `-- name: GetAssetByID :one
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE asset_id = $1 AND is_deleted = false
`

func (q *Queries) GetAssetByID(ctx context.Context, assetID pgtype.UUID) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByID, assetID)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Embedding,
	)
	return i, err
}

const getAssetsByHash = `-- name: GetAssetsByHash :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE hash = $1 AND is_deleted = false
`

func (q *Queries) GetAssetsByHash(ctx context.Context, hash *string) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByHash, hash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByOwner = `-- name: GetAssetsByOwner :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE owner_id = $1 AND is_deleted = false
ORDER BY upload_time DESC
LIMIT $2 OFFSET $3
`

type GetAssetsByOwnerParams struct {
	OwnerID *int32 `db:"owner_id" json:"owner_id"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAssetsByOwner(ctx context.Context, arg GetAssetsByOwnerParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByRating = `-- name: GetAssetsByRating :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE is_deleted = false
  AND (specific_metadata->>'rating')::integer = $1::integer
ORDER BY upload_time DESC
LIMIT $3 OFFSET $2
`

type GetAssetsByRatingParams struct {
	Rating int32 `db:"rating" json:"rating"`
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetAssetsByRating(ctx context.Context, arg GetAssetsByRatingParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByRating, arg.Rating, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByType = `-- name: GetAssetsByType :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE type = $1 AND is_deleted = false
ORDER BY upload_time DESC
LIMIT $2 OFFSET $3
`

type GetAssetsByTypeParams struct {
	Type   string `db:"type" json:"type"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAssetsByType(ctx context.Context, arg GetAssetsByTypeParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctCameraMakes = `-- name: GetDistinctCameraMakes :many
SELECT DISTINCT a.specific_metadata->>'camera_model' as camera_model
FROM assets a
WHERE a.is_deleted = false
  AND a.specific_metadata->>'camera_model' IS NOT NULL
  AND a.specific_metadata->>'camera_model' != ''
ORDER BY camera_model
`

func (q *Queries) GetDistinctCameraMakes(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getDistinctCameraMakes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var camera_model interface{}
		if err := rows.Scan(&camera_model); err != nil {
			return nil, err
		}
		items = append(items, camera_model)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctLenses = `-- name: GetDistinctLenses :many
SELECT DISTINCT a.specific_metadata->>'lens_model' as lens_model
FROM assets a
WHERE a.is_deleted = false
  AND a.specific_metadata->>'lens_model' IS NOT NULL
  AND a.specific_metadata->>'lens_model' != ''
ORDER BY lens_model
`

func (q *Queries) GetDistinctLenses(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getDistinctLenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var lens_model interface{}
		if err := rows.Scan(&lens_model); err != nil {
			return nil, err
		}
		items = append(items, lens_model)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedAssets = `-- name: GetLikedAssets :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE is_deleted = false
  AND (specific_metadata->>'liked')::boolean = true
ORDER BY upload_time DESC
LIMIT $2 OFFSET $1
`

type GetLikedAssetsParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetLikedAssets(ctx context.Context, arg GetLikedAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getLikedAssets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThumbnailByAssetAndSize = `-- name: GetThumbnailByAssetAndSize :one
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails
WHERE asset_id = $1 AND size = $2
`

type GetThumbnailByAssetAndSizeParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	Size    string      `db:"size" json:"size"`
}

func (q *Queries) GetThumbnailByAssetAndSize(ctx context.Context, arg GetThumbnailByAssetAndSizeParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, getThumbnailByAssetAndSize, arg.AssetID, arg.Size)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const getThumbnailByID = `-- name: GetThumbnailByID :one
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails WHERE thumbnail_id = $1
`

func (q *Queries) GetThumbnailByID(ctx context.Context, thumbnailID int32) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, getThumbnailByID, thumbnailID)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const getThumbnailsByAsset = `-- name: GetThumbnailsByAsset :many
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails
WHERE asset_id = $1
ORDER BY CASE size
    WHEN 'small' THEN 1
    WHEN 'medium' THEN 2
    WHEN 'large' THEN 3
END, thumbnail_id
`

func (q *Queries) GetThumbnailsByAsset(ctx context.Context, assetID pgtype.UUID) ([]Thumbnail, error) {
	rows, err := q.db.Query(ctx, getThumbnailsByAsset, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thumbnail
	for rows.Next() {
		var i Thumbnail
		if err := rows.Scan(
			&i.ThumbnailID,
			&i.AssetID,
			&i.Size,
			&i.StoragePath,
			&i.MimeType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAssetFromAlbum = `-- name: RemoveAssetFromAlbum :exec
DELETE FROM album_assets
WHERE asset_id = $1 AND album_id = $2
`

type RemoveAssetFromAlbumParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	AlbumID int32       `db:"album_id" json:"album_id"`
}

func (q *Queries) RemoveAssetFromAlbum(ctx context.Context, arg RemoveAssetFromAlbumParams) error {
	_, err := q.db.Exec(ctx, removeAssetFromAlbum, arg.AssetID, arg.AlbumID)
	return err
}

const removeTagFromAsset = `-- name: RemoveTagFromAsset :exec
DELETE FROM asset_tags
WHERE asset_id = $1 AND tag_id = $2
`

type RemoveTagFromAssetParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	TagID   int32       `db:"tag_id" json:"tag_id"`
}

func (q *Queries) RemoveTagFromAsset(ctx context.Context, arg RemoveTagFromAssetParams) error {
	_, err := q.db.Exec(ctx, removeTagFromAsset, arg.AssetID, arg.TagID)
	return err
}

const searchAssets = `-- name: SearchAssets :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE is_deleted = false
AND ($1::text IS NULL OR original_filename ILIKE '%' || $1 || '%')
AND ($2::text IS NULL OR type = $2)
ORDER BY upload_time DESC
LIMIT $3 OFFSET $4
`

type SearchAssetsParams struct {
	Column1 string `db:"column_1" json:"column_1"`
	Column2 string `db:"column_2" json:"column_2"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchAssets(ctx context.Context, arg SearchAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssets,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsFilename = `-- name: SearchAssetsFilename :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.embedding FROM assets a
WHERE a.is_deleted = false
  AND a.original_filename ILIKE '%' || $1 || '%'
  AND ($2::text IS NULL OR a.type = $2)
  AND ($3::integer IS NULL OR a.owner_id = $3)
  AND ($4::text IS NULL OR
    CASE $5::text
      WHEN 'contains' THEN a.original_filename ILIKE '%' || $4 || '%'
      WHEN 'matches' THEN a.original_filename ILIKE $4
      WHEN 'startswith' THEN a.original_filename ILIKE $4 || '%'
      WHEN 'endswith' THEN a.original_filename ILIKE '%' || $4
      ELSE true
    END
  )
  AND ($6::timestamptz IS NULL OR a.upload_time >= $6)
  AND ($7::timestamptz IS NULL OR a.upload_time <= $7)
  AND ($8::boolean IS NULL OR
    CASE
      WHEN $8 = true THEN (a.specific_metadata->>'is_raw')::boolean = true
      WHEN $8 = false THEN (a.specific_metadata->>'is_raw')::boolean = false OR a.specific_metadata->>'is_raw' IS NULL
      ELSE true
    END
  )
  AND ($9::integer IS NULL OR
    CASE
      WHEN $9 = 0 THEN a.specific_metadata->>'rating' IS NULL
      ELSE (a.specific_metadata->>'rating')::integer = $9
    END
  )
  AND ($10::boolean IS NULL OR (a.specific_metadata->>'liked')::boolean = $10)
  AND ($11::text IS NULL OR a.specific_metadata->>'camera_model' = $11)
  AND ($12::text IS NULL OR a.specific_metadata->>'lens_model' = $12)
ORDER BY a.upload_time DESC
LIMIT $14 OFFSET $13
`

type SearchAssetsFilenameParams struct {
	Query        *string            `db:"query" json:"query"`
	AssetType    *string            `db:"asset_type" json:"asset_type"`
	OwnerID      *int32             `db:"owner_id" json:"owner_id"`
	FilenameVal  *string            `db:"filename_val" json:"filename_val"`
	FilenameMode *string            `db:"filename_mode" json:"filename_mode"`
	DateFrom     pgtype.Timestamptz `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamptz `db:"date_to" json:"date_to"`
	IsRaw        *bool              `db:"is_raw" json:"is_raw"`
	Rating       *int32             `db:"rating" json:"rating"`
	Liked        *bool              `db:"liked" json:"liked"`
	CameraModel  *string            `db:"camera_model" json:"camera_model"`
	LensModel    *string            `db:"lens_model" json:"lens_model"`
	Offset       int32              `db:"offset" json:"offset"`
	Limit        int32              `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsFilename(ctx context.Context, arg SearchAssetsFilenameParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsFilename,
		arg.Query,
		arg.AssetType,
		arg.OwnerID,
		arg.FilenameVal,
		arg.FilenameMode,
		arg.DateFrom,
		arg.DateTo,
		arg.IsRaw,
		arg.Rating,
		arg.Liked,
		arg.CameraModel,
		arg.LensModel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsVector = `-- name: SearchAssetsVector :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.embedding, (a.embedding <-> $1::vector) AS distance FROM assets a
WHERE a.is_deleted = false
  AND a.embedding IS NOT NULL
  AND ($2::text IS NULL OR a.type = $2)
  AND ($3::integer IS NULL OR a.owner_id = $3)
  AND ($4::text IS NULL OR
    CASE $5::text
      WHEN 'contains' THEN a.original_filename ILIKE '%' || $4 || '%'
      WHEN 'matches' THEN a.original_filename ILIKE $4
      WHEN 'startswith' THEN a.original_filename ILIKE $4 || '%'
      WHEN 'endswith' THEN a.original_filename ILIKE '%' || $4
      ELSE true
    END
  )
  AND ($6::timestamptz IS NULL OR a.upload_time >= $6)
  AND ($7::timestamptz IS NULL OR a.upload_time <= $7)
  AND ($8::boolean IS NULL OR
    CASE
      WHEN $8 = true THEN (a.specific_metadata->>'is_raw')::boolean = true
      WHEN $8 = false THEN (a.specific_metadata->>'is_raw')::boolean = false OR a.specific_metadata->>'is_raw' IS NULL
      ELSE true
    END
  )
  AND ($9::integer IS NULL OR
    CASE
      WHEN $9 = 0 THEN a.specific_metadata->>'rating' IS NULL
      ELSE (a.specific_metadata->>'rating')::integer = $9
    END
  )
  AND ($10::boolean IS NULL OR (a.specific_metadata->>'liked')::boolean = $10)
  AND ($11::text IS NULL OR a.specific_metadata->>'camera_model' = $11)
  AND ($12::text IS NULL OR a.specific_metadata->>'lens_model' = $12)
ORDER BY (a.embedding <-> $1::vector)
LIMIT $14 OFFSET $13
`

type SearchAssetsVectorParams struct {
	Embedding    pgvector_go.Vector `db:"embedding" json:"embedding"`
	AssetType    *string            `db:"asset_type" json:"asset_type"`
	OwnerID      *int32             `db:"owner_id" json:"owner_id"`
	FilenameVal  *string            `db:"filename_val" json:"filename_val"`
	FilenameMode *string            `db:"filename_mode" json:"filename_mode"`
	DateFrom     pgtype.Timestamptz `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamptz `db:"date_to" json:"date_to"`
	IsRaw        *bool              `db:"is_raw" json:"is_raw"`
	Rating       *int32             `db:"rating" json:"rating"`
	Liked        *bool              `db:"liked" json:"liked"`
	CameraModel  *string            `db:"camera_model" json:"camera_model"`
	LensModel    *string            `db:"lens_model" json:"lens_model"`
	Offset       int32              `db:"offset" json:"offset"`
	Limit        int32              `db:"limit" json:"limit"`
}

type SearchAssetsVectorRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      string                   `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Embedding        *pgvector_go.Vector      `db:"embedding" json:"embedding"`
	Distance         interface{}              `db:"distance" json:"distance"`
}

func (q *Queries) SearchAssetsVector(ctx context.Context, arg SearchAssetsVectorParams) ([]SearchAssetsVectorRow, error) {
	rows, err := q.db.Query(ctx, searchAssetsVector,
		arg.Embedding,
		arg.AssetType,
		arg.OwnerID,
		arg.FilenameVal,
		arg.FilenameMode,
		arg.DateFrom,
		arg.DateTo,
		arg.IsRaw,
		arg.Rating,
		arg.Liked,
		arg.CameraModel,
		arg.LensModel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAssetsVectorRow
	for rows.Next() {
		var i SearchAssetsVectorRow
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE assets
SET original_filename = $2, specific_metadata = $3, updated_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
RETURNING asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding
`

type UpdateAssetParams struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, updateAsset, arg.AssetID, arg.OriginalFilename, arg.SpecificMetadata)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Embedding,
	)
	return i, err
}

const updateAssetDescription = `-- name: UpdateAssetDescription :exec
UPDATE assets
SET specific_metadata = jsonb_set(
    COALESCE(specific_metadata, '{}'::jsonb),
    '{description}',
    to_jsonb($1::text)
)
WHERE asset_id = $2
`

type UpdateAssetDescriptionParams struct {
	Description string      `db:"description" json:"description"`
	AssetID     pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetDescription(ctx context.Context, arg UpdateAssetDescriptionParams) error {
	_, err := q.db.Exec(ctx, updateAssetDescription, arg.Description, arg.AssetID)
	return err
}

const updateAssetLike = `-- name: UpdateAssetLike :exec
UPDATE assets
SET specific_metadata = jsonb_set(
    COALESCE(specific_metadata, '{}'::jsonb),
    '{liked}',
    to_jsonb($1::boolean)
)
WHERE asset_id = $2
`

type UpdateAssetLikeParams struct {
	Liked   bool        `db:"liked" json:"liked"`
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetLike(ctx context.Context, arg UpdateAssetLikeParams) error {
	_, err := q.db.Exec(ctx, updateAssetLike, arg.Liked, arg.AssetID)
	return err
}

const updateAssetMetadata = `-- name: UpdateAssetMetadata :exec
UPDATE assets
SET specific_metadata = $2
WHERE asset_id = $1
`

type UpdateAssetMetadataParams struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) UpdateAssetMetadata(ctx context.Context, arg UpdateAssetMetadataParams) error {
	_, err := q.db.Exec(ctx, updateAssetMetadata, arg.AssetID, arg.SpecificMetadata)
	return err
}

const updateAssetRating = `-- name: UpdateAssetRating :exec
UPDATE assets
SET specific_metadata = jsonb_set(
    COALESCE(specific_metadata, '{}'::jsonb),
    '{rating}',
    to_jsonb($1::integer)
)
WHERE asset_id = $2
`

type UpdateAssetRatingParams struct {
	Rating  int32       `db:"rating" json:"rating"`
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetRating(ctx context.Context, arg UpdateAssetRatingParams) error {
	_, err := q.db.Exec(ctx, updateAssetRating, arg.Rating, arg.AssetID)
	return err
}

const updateAssetRatingAndLike = `-- name: UpdateAssetRatingAndLike :exec
UPDATE assets
SET specific_metadata = jsonb_set(
    jsonb_set(
        COALESCE(specific_metadata, '{}'::jsonb),
        '{rating}',
        to_jsonb($1::integer)
    ),
    '{liked}',
    to_jsonb($2::boolean)
)
WHERE asset_id = $3
`

type UpdateAssetRatingAndLikeParams struct {
	Rating  int32       `db:"rating" json:"rating"`
	Liked   bool        `db:"liked" json:"liked"`
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
}

func (q *Queries) UpdateAssetRatingAndLike(ctx context.Context, arg UpdateAssetRatingAndLikeParams) error {
	_, err := q.db.Exec(ctx, updateAssetRatingAndLike, arg.Rating, arg.Liked, arg.AssetID)
	return err
}
