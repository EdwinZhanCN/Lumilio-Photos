// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assets.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAssetToAlbum = `-- name: AddAssetToAlbum :exec
INSERT INTO album_assets (asset_id, album_id, position)
VALUES ($1, $2, $3)
ON CONFLICT (asset_id, album_id) DO NOTHING
`

type AddAssetToAlbumParams struct {
	AssetID  pgtype.UUID `db:"asset_id" json:"asset_id"`
	AlbumID  int32       `db:"album_id" json:"album_id"`
	Position *int32      `db:"position" json:"position"`
}

func (q *Queries) AddAssetToAlbum(ctx context.Context, arg AddAssetToAlbumParams) error {
	_, err := q.db.Exec(ctx, addAssetToAlbum, arg.AssetID, arg.AlbumID, arg.Position)
	return err
}

const addTagToAsset = `-- name: AddTagToAsset :exec
INSERT INTO asset_tags (asset_id, tag_id, confidence, source)
VALUES ($1, $2, $3, $4)
ON CONFLICT (asset_id, tag_id) DO UPDATE
SET confidence = $3, source = $4
`

type AddTagToAssetParams struct {
	AssetID    pgtype.UUID    `db:"asset_id" json:"asset_id"`
	TagID      int32          `db:"tag_id" json:"tag_id"`
	Confidence pgtype.Numeric `db:"confidence" json:"confidence"`
	Source     string         `db:"source" json:"source"`
}

func (q *Queries) AddTagToAsset(ctx context.Context, arg AddTagToAssetParams) error {
	_, err := q.db.Exec(ctx, addTagToAsset,
		arg.AssetID,
		arg.TagID,
		arg.Confidence,
		arg.Source,
	)
	return err
}

const createAsset = `-- name: CreateAsset :one
INSERT INTO assets (
    owner_id, type, original_filename, storage_path, mime_type,
    file_size, hash, width, height, duration, specific_metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding
`

type CreateAssetParams struct {
	OwnerID          *int32   `db:"owner_id" json:"owner_id"`
	Type             string   `db:"type" json:"type"`
	OriginalFilename string   `db:"original_filename" json:"original_filename"`
	StoragePath      string   `db:"storage_path" json:"storage_path"`
	MimeType         string   `db:"mime_type" json:"mime_type"`
	FileSize         int64    `db:"file_size" json:"file_size"`
	Hash             *string  `db:"hash" json:"hash"`
	Width            *int32   `db:"width" json:"width"`
	Height           *int32   `db:"height" json:"height"`
	Duration         *float64 `db:"duration" json:"duration"`
	SpecificMetadata []byte   `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, createAsset,
		arg.OwnerID,
		arg.Type,
		arg.OriginalFilename,
		arg.StoragePath,
		arg.MimeType,
		arg.FileSize,
		arg.Hash,
		arg.Width,
		arg.Height,
		arg.Duration,
		arg.SpecificMetadata,
	)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Embedding,
	)
	return i, err
}

const createThumbnail = `-- name: CreateThumbnail :one
INSERT INTO thumbnails (asset_id, size, storage_path, mime_type)
VALUES ($1, $2, $3, $4)
RETURNING thumbnail_id, asset_id, size, storage_path, mime_type, created_at
`

type CreateThumbnailParams struct {
	AssetID     pgtype.UUID `db:"asset_id" json:"asset_id"`
	Size        string      `db:"size" json:"size"`
	StoragePath string      `db:"storage_path" json:"storage_path"`
	MimeType    string      `db:"mime_type" json:"mime_type"`
}

func (q *Queries) CreateThumbnail(ctx context.Context, arg CreateThumbnailParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, createThumbnail,
		arg.AssetID,
		arg.Size,
		arg.StoragePath,
		arg.MimeType,
	)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAsset = `-- name: DeleteAsset :exec
UPDATE assets
SET is_deleted = true, deleted_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
`

func (q *Queries) DeleteAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAsset, assetID)
	return err
}

const getAssetByID = `-- name: GetAssetByID :one
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE asset_id = $1 AND is_deleted = false
`

func (q *Queries) GetAssetByID(ctx context.Context, assetID pgtype.UUID) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByID, assetID)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Embedding,
	)
	return i, err
}

const getAssetsByHash = `-- name: GetAssetsByHash :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE hash = $1 AND is_deleted = false
`

func (q *Queries) GetAssetsByHash(ctx context.Context, hash *string) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByHash, hash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByOwner = `-- name: GetAssetsByOwner :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE owner_id = $1 AND is_deleted = false
ORDER BY upload_time DESC
LIMIT $2 OFFSET $3
`

type GetAssetsByOwnerParams struct {
	OwnerID *int32 `db:"owner_id" json:"owner_id"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAssetsByOwner(ctx context.Context, arg GetAssetsByOwnerParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsByType = `-- name: GetAssetsByType :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE type = $1 AND is_deleted = false
ORDER BY upload_time DESC
LIMIT $2 OFFSET $3
`

type GetAssetsByTypeParams struct {
	Type   string `db:"type" json:"type"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAssetsByType(ctx context.Context, arg GetAssetsByTypeParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThumbnailByAssetAndSize = `-- name: GetThumbnailByAssetAndSize :one
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails
WHERE asset_id = $1 AND size = $2
`

type GetThumbnailByAssetAndSizeParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	Size    string      `db:"size" json:"size"`
}

func (q *Queries) GetThumbnailByAssetAndSize(ctx context.Context, arg GetThumbnailByAssetAndSizeParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, getThumbnailByAssetAndSize, arg.AssetID, arg.Size)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const getThumbnailByID = `-- name: GetThumbnailByID :one
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails WHERE thumbnail_id = $1
`

func (q *Queries) GetThumbnailByID(ctx context.Context, thumbnailID int32) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, getThumbnailByID, thumbnailID)
	var i Thumbnail
	err := row.Scan(
		&i.ThumbnailID,
		&i.AssetID,
		&i.Size,
		&i.StoragePath,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const getThumbnailsByAsset = `-- name: GetThumbnailsByAsset :many
SELECT thumbnail_id, asset_id, size, storage_path, mime_type, created_at FROM thumbnails
WHERE asset_id = $1
ORDER BY CASE size
    WHEN 'small' THEN 1
    WHEN 'medium' THEN 2
    WHEN 'large' THEN 3
END, thumbnail_id
`

func (q *Queries) GetThumbnailsByAsset(ctx context.Context, assetID pgtype.UUID) ([]Thumbnail, error) {
	rows, err := q.db.Query(ctx, getThumbnailsByAsset, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thumbnail
	for rows.Next() {
		var i Thumbnail
		if err := rows.Scan(
			&i.ThumbnailID,
			&i.AssetID,
			&i.Size,
			&i.StoragePath,
			&i.MimeType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAssetFromAlbum = `-- name: RemoveAssetFromAlbum :exec
DELETE FROM album_assets
WHERE asset_id = $1 AND album_id = $2
`

type RemoveAssetFromAlbumParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	AlbumID int32       `db:"album_id" json:"album_id"`
}

func (q *Queries) RemoveAssetFromAlbum(ctx context.Context, arg RemoveAssetFromAlbumParams) error {
	_, err := q.db.Exec(ctx, removeAssetFromAlbum, arg.AssetID, arg.AlbumID)
	return err
}

const removeTagFromAsset = `-- name: RemoveTagFromAsset :exec
DELETE FROM asset_tags
WHERE asset_id = $1 AND tag_id = $2
`

type RemoveTagFromAssetParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	TagID   int32       `db:"tag_id" json:"tag_id"`
}

func (q *Queries) RemoveTagFromAsset(ctx context.Context, arg RemoveTagFromAssetParams) error {
	_, err := q.db.Exec(ctx, removeTagFromAsset, arg.AssetID, arg.TagID)
	return err
}

const searchAssets = `-- name: SearchAssets :many
SELECT asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding FROM assets
WHERE is_deleted = false
AND ($1::text IS NULL OR original_filename ILIKE '%' || $1 || '%')
AND ($2::text IS NULL OR type = $2)
ORDER BY upload_time DESC
LIMIT $3 OFFSET $4
`

type SearchAssetsParams struct {
	Column1 string `db:"column_1" json:"column_1"`
	Column2 string `db:"column_2" json:"column_2"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchAssets(ctx context.Context, arg SearchAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssets,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE assets
SET original_filename = $2, specific_metadata = $3, updated_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
RETURNING asset_id, owner_id, type, original_filename, storage_path, mime_type, file_size, hash, width, height, duration, upload_time, is_deleted, deleted_at, specific_metadata, embedding
`

type UpdateAssetParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	OriginalFilename string      `db:"original_filename" json:"original_filename"`
	SpecificMetadata []byte      `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, updateAsset, arg.AssetID, arg.OriginalFilename, arg.SpecificMetadata)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Embedding,
	)
	return i, err
}

const updateAssetMetadata = `-- name: UpdateAssetMetadata :exec
UPDATE assets
SET specific_metadata = $2
WHERE asset_id = $1
`

type UpdateAssetMetadataParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	SpecificMetadata []byte      `db:"specific_metadata" json:"specific_metadata"`
}

func (q *Queries) UpdateAssetMetadata(ctx context.Context, arg UpdateAssetMetadataParams) error {
	_, err := q.db.Exec(ctx, updateAssetMetadata, arg.AssetID, arg.SpecificMetadata)
	return err
}
