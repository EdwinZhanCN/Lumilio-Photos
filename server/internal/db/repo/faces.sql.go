// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: faces.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createFaceCluster = `-- name: CreateFaceCluster :one
INSERT INTO face_clusters (cluster_name, representative_face_id, confidence_score, is_confirmed)
VALUES ($1, $2, $3, $4)
RETURNING cluster_id, cluster_name, representative_face_id, confidence_score, member_count, is_confirmed, created_at, updated_at
`

type CreateFaceClusterParams struct {
	ClusterName          *string  `db:"cluster_name" json:"cluster_name"`
	RepresentativeFaceID int32    `db:"representative_face_id" json:"representative_face_id"`
	ConfidenceScore      *float32 `db:"confidence_score" json:"confidence_score"`
	IsConfirmed          *bool    `db:"is_confirmed" json:"is_confirmed"`
}

func (q *Queries) CreateFaceCluster(ctx context.Context, arg CreateFaceClusterParams) (FaceCluster, error) {
	row := q.db.QueryRow(ctx, createFaceCluster,
		arg.ClusterName,
		arg.RepresentativeFaceID,
		arg.ConfidenceScore,
		arg.IsConfirmed,
	)
	var i FaceCluster
	err := row.Scan(
		&i.ClusterID,
		&i.ClusterName,
		&i.RepresentativeFaceID,
		&i.ConfidenceScore,
		&i.MemberCount,
		&i.IsConfirmed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFaceClusterMember = `-- name: CreateFaceClusterMember :one
INSERT INTO face_cluster_members (cluster_id, face_id, similarity_score, confidence, is_manual)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, cluster_id, face_id, similarity_score, confidence, is_manual, created_at
`

type CreateFaceClusterMemberParams struct {
	ClusterID       int32   `db:"cluster_id" json:"cluster_id"`
	FaceID          int32   `db:"face_id" json:"face_id"`
	SimilarityScore float32 `db:"similarity_score" json:"similarity_score"`
	Confidence      float32 `db:"confidence" json:"confidence"`
	IsManual        *bool   `db:"is_manual" json:"is_manual"`
}

func (q *Queries) CreateFaceClusterMember(ctx context.Context, arg CreateFaceClusterMemberParams) (FaceClusterMember, error) {
	row := q.db.QueryRow(ctx, createFaceClusterMember,
		arg.ClusterID,
		arg.FaceID,
		arg.SimilarityScore,
		arg.Confidence,
		arg.IsManual,
	)
	var i FaceClusterMember
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.FaceID,
		&i.SimilarityScore,
		&i.Confidence,
		&i.IsManual,
		&i.CreatedAt,
	)
	return i, err
}

const createFaceItem = `-- name: CreateFaceItem :one
INSERT INTO face_items (
    asset_id, face_id, bounding_box, confidence, age_group, gender,
    ethnicity, expression, face_size, face_image_path, embedding,
    embedding_model, is_primary, quality_score, blur_score, pose_angles
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at
`

type CreateFaceItemParams struct {
	AssetID        pgtype.UUID      `db:"asset_id" json:"asset_id"`
	FaceID         *string          `db:"face_id" json:"face_id"`
	BoundingBox    []byte           `db:"bounding_box" json:"bounding_box"`
	Confidence     float32          `db:"confidence" json:"confidence"`
	AgeGroup       *string          `db:"age_group" json:"age_group"`
	Gender         *string          `db:"gender" json:"gender"`
	Ethnicity      *string          `db:"ethnicity" json:"ethnicity"`
	Expression     *string          `db:"expression" json:"expression"`
	FaceSize       *int32           `db:"face_size" json:"face_size"`
	FaceImagePath  *string          `db:"face_image_path" json:"face_image_path"`
	Embedding      *pgvector.Vector `db:"embedding" json:"embedding"`
	EmbeddingModel *string          `db:"embedding_model" json:"embedding_model"`
	IsPrimary      *bool            `db:"is_primary" json:"is_primary"`
	QualityScore   *float32         `db:"quality_score" json:"quality_score"`
	BlurScore      *float32         `db:"blur_score" json:"blur_score"`
	PoseAngles     []byte           `db:"pose_angles" json:"pose_angles"`
}

func (q *Queries) CreateFaceItem(ctx context.Context, arg CreateFaceItemParams) (FaceItem, error) {
	row := q.db.QueryRow(ctx, createFaceItem,
		arg.AssetID,
		arg.FaceID,
		arg.BoundingBox,
		arg.Confidence,
		arg.AgeGroup,
		arg.Gender,
		arg.Ethnicity,
		arg.Expression,
		arg.FaceSize,
		arg.FaceImagePath,
		arg.Embedding,
		arg.EmbeddingModel,
		arg.IsPrimary,
		arg.QualityScore,
		arg.BlurScore,
		arg.PoseAngles,
	)
	var i FaceItem
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.FaceID,
		&i.BoundingBox,
		&i.Confidence,
		&i.AgeGroup,
		&i.Gender,
		&i.Ethnicity,
		&i.Expression,
		&i.FaceSize,
		&i.FaceImagePath,
		&i.Embedding,
		&i.EmbeddingModel,
		&i.IsPrimary,
		&i.QualityScore,
		&i.BlurScore,
		&i.PoseAngles,
		&i.CreatedAt,
	)
	return i, err
}

const createFaceResult = `-- name: CreateFaceResult :one
INSERT INTO face_results (asset_id, model_id, total_faces, processing_time_ms)
VALUES ($1, $2, $3, $4)
RETURNING asset_id, model_id, total_faces, processing_time_ms, created_at, updated_at
`

type CreateFaceResultParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	ModelID          string      `db:"model_id" json:"model_id"`
	TotalFaces       int32       `db:"total_faces" json:"total_faces"`
	ProcessingTimeMs *int32      `db:"processing_time_ms" json:"processing_time_ms"`
}

func (q *Queries) CreateFaceResult(ctx context.Context, arg CreateFaceResultParams) (FaceResult, error) {
	row := q.db.QueryRow(ctx, createFaceResult,
		arg.AssetID,
		arg.ModelID,
		arg.TotalFaces,
		arg.ProcessingTimeMs,
	)
	var i FaceResult
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.TotalFaces,
		&i.ProcessingTimeMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFaceCluster = `-- name: DeleteFaceCluster :exec
DELETE FROM face_clusters WHERE cluster_id = $1
`

func (q *Queries) DeleteFaceCluster(ctx context.Context, clusterID int32) error {
	_, err := q.db.Exec(ctx, deleteFaceCluster, clusterID)
	return err
}

const deleteFaceClusterMember = `-- name: DeleteFaceClusterMember :exec
DELETE FROM face_cluster_members
WHERE cluster_id = $1 AND face_id = $2
`

type DeleteFaceClusterMemberParams struct {
	ClusterID int32 `db:"cluster_id" json:"cluster_id"`
	FaceID    int32 `db:"face_id" json:"face_id"`
}

func (q *Queries) DeleteFaceClusterMember(ctx context.Context, arg DeleteFaceClusterMemberParams) error {
	_, err := q.db.Exec(ctx, deleteFaceClusterMember, arg.ClusterID, arg.FaceID)
	return err
}

const deleteFaceItemsByAsset = `-- name: DeleteFaceItemsByAsset :exec
DELETE FROM face_items WHERE asset_id = $1
`

func (q *Queries) DeleteFaceItemsByAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFaceItemsByAsset, assetID)
	return err
}

const deleteFaceResultByAsset = `-- name: DeleteFaceResultByAsset :exec
DELETE FROM face_results WHERE asset_id = $1
`

func (q *Queries) DeleteFaceResultByAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFaceResultByAsset, assetID)
	return err
}

const getAllFaceClusters = `-- name: GetAllFaceClusters :many
SELECT cluster_id, cluster_name, representative_face_id, confidence_score, member_count, is_confirmed, created_at, updated_at FROM face_clusters
ORDER BY is_confirmed DESC, member_count DESC
`

func (q *Queries) GetAllFaceClusters(ctx context.Context) ([]FaceCluster, error) {
	rows, err := q.db.Query(ctx, getAllFaceClusters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceCluster
	for rows.Next() {
		var i FaceCluster
		if err := rows.Scan(
			&i.ClusterID,
			&i.ClusterName,
			&i.RepresentativeFaceID,
			&i.ConfidenceScore,
			&i.MemberCount,
			&i.IsConfirmed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClusterMergeCandidates = `-- name: GetClusterMergeCandidates :many
SELECT
    fc1.cluster_id,
    fc1.cluster_name as name1,
    fc2.cluster_id as other_cluster_id,
    fc2.cluster_name as name2,
    -- Calculate average similarity between cluster members
    (SELECT AVG(1 - (fi1.embedding <=> fi2.embedding))
     FROM face_cluster_members fcm1
     JOIN face_items fi1 ON fcm1.face_id = fi1.id
     JOIN face_cluster_members fcm2 ON fcm1.cluster_id = fc1.cluster_id
     JOIN face_items fi2 ON fcm2.face_id = fi2.id
     WHERE fcm2.cluster_id = fc2.cluster_id
     LIMIT 100) as avg_similarity
FROM face_clusters fc1
CROSS JOIN face_clusters fc2
WHERE fc1.cluster_id < fc2.cluster_id
AND fc1.is_confirmed = true
AND fc2.is_confirmed = true
HAVING AVG(1 - (fi1.embedding <=> fi2.embedding)) >= $1
ORDER BY avg_similarity DESC
LIMIT $2
`

type GetClusterMergeCandidatesParams struct {
	Embedding *pgvector.Vector `db:"embedding" json:"embedding"`
	Limit     int32            `db:"limit" json:"limit"`
}

type GetClusterMergeCandidatesRow struct {
	ClusterID      int32   `db:"cluster_id" json:"cluster_id"`
	Name1          *string `db:"name1" json:"name1"`
	OtherClusterID int32   `db:"other_cluster_id" json:"other_cluster_id"`
	Name2          *string `db:"name2" json:"name2"`
	AvgSimilarity  float64 `db:"avg_similarity" json:"avg_similarity"`
}

func (q *Queries) GetClusterMergeCandidates(ctx context.Context, arg GetClusterMergeCandidatesParams) ([]GetClusterMergeCandidatesRow, error) {
	rows, err := q.db.Query(ctx, getClusterMergeCandidates, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClusterMergeCandidatesRow
	for rows.Next() {
		var i GetClusterMergeCandidatesRow
		if err := rows.Scan(
			&i.ClusterID,
			&i.Name1,
			&i.OtherClusterID,
			&i.Name2,
			&i.AvgSimilarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfirmedFaceClusters = `-- name: GetConfirmedFaceClusters :many
SELECT cluster_id, cluster_name, representative_face_id, confidence_score, member_count, is_confirmed, created_at, updated_at FROM face_clusters
WHERE is_confirmed = true
ORDER BY cluster_name ASC
`

func (q *Queries) GetConfirmedFaceClusters(ctx context.Context) ([]FaceCluster, error) {
	rows, err := q.db.Query(ctx, getConfirmedFaceClusters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceCluster
	for rows.Next() {
		var i FaceCluster
		if err := rows.Scan(
			&i.ClusterID,
			&i.ClusterName,
			&i.RepresentativeFaceID,
			&i.ConfidenceScore,
			&i.MemberCount,
			&i.IsConfirmed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaceClusterByFaceID = `-- name: GetFaceClusterByFaceID :one
SELECT fc.cluster_id, fc.cluster_name, fc.representative_face_id, fc.confidence_score, fc.member_count, fc.is_confirmed, fc.created_at, fc.updated_at FROM face_clusters fc
JOIN face_cluster_members fcm ON fc.cluster_id = fcm.cluster_id
WHERE fcm.face_id = $1
`

func (q *Queries) GetFaceClusterByFaceID(ctx context.Context, faceID int32) (FaceCluster, error) {
	row := q.db.QueryRow(ctx, getFaceClusterByFaceID, faceID)
	var i FaceCluster
	err := row.Scan(
		&i.ClusterID,
		&i.ClusterName,
		&i.RepresentativeFaceID,
		&i.ConfidenceScore,
		&i.MemberCount,
		&i.IsConfirmed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFaceClusterByID = `-- name: GetFaceClusterByID :one
SELECT cluster_id, cluster_name, representative_face_id, confidence_score, member_count, is_confirmed, created_at, updated_at FROM face_clusters
WHERE cluster_id = $1
`

func (q *Queries) GetFaceClusterByID(ctx context.Context, clusterID int32) (FaceCluster, error) {
	row := q.db.QueryRow(ctx, getFaceClusterByID, clusterID)
	var i FaceCluster
	err := row.Scan(
		&i.ClusterID,
		&i.ClusterName,
		&i.RepresentativeFaceID,
		&i.ConfidenceScore,
		&i.MemberCount,
		&i.IsConfirmed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFaceClusterByRepresentative = `-- name: GetFaceClusterByRepresentative :one
SELECT cluster_id, cluster_name, representative_face_id, confidence_score, member_count, is_confirmed, created_at, updated_at FROM face_clusters
WHERE representative_face_id = $1
`

func (q *Queries) GetFaceClusterByRepresentative(ctx context.Context, representativeFaceID int32) (FaceCluster, error) {
	row := q.db.QueryRow(ctx, getFaceClusterByRepresentative, representativeFaceID)
	var i FaceCluster
	err := row.Scan(
		&i.ClusterID,
		&i.ClusterName,
		&i.RepresentativeFaceID,
		&i.ConfidenceScore,
		&i.MemberCount,
		&i.IsConfirmed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFaceClusterMembers = `-- name: GetFaceClusterMembers :many
SELECT fi.id, fi.asset_id, fi.face_id, fi.bounding_box, fi.confidence, fi.age_group, fi.gender, fi.ethnicity, fi.expression, fi.face_size, fi.face_image_path, fi.embedding, fi.embedding_model, fi.is_primary, fi.quality_score, fi.blur_score, fi.pose_angles, fi.created_at, fcm.similarity_score, fcm.confidence, fcm.is_manual
FROM face_cluster_members fcm
JOIN face_items fi ON fcm.face_id = fi.id
WHERE fcm.cluster_id = $1
ORDER BY fcm.confidence DESC
`

type GetFaceClusterMembersRow struct {
	ID              int32              `db:"id" json:"id"`
	AssetID         pgtype.UUID        `db:"asset_id" json:"asset_id"`
	FaceID          *string            `db:"face_id" json:"face_id"`
	BoundingBox     []byte             `db:"bounding_box" json:"bounding_box"`
	Confidence      float32            `db:"confidence" json:"confidence"`
	AgeGroup        *string            `db:"age_group" json:"age_group"`
	Gender          *string            `db:"gender" json:"gender"`
	Ethnicity       *string            `db:"ethnicity" json:"ethnicity"`
	Expression      *string            `db:"expression" json:"expression"`
	FaceSize        *int32             `db:"face_size" json:"face_size"`
	FaceImagePath   *string            `db:"face_image_path" json:"face_image_path"`
	Embedding       *pgvector.Vector   `db:"embedding" json:"embedding"`
	EmbeddingModel  *string            `db:"embedding_model" json:"embedding_model"`
	IsPrimary       *bool              `db:"is_primary" json:"is_primary"`
	QualityScore    *float32           `db:"quality_score" json:"quality_score"`
	BlurScore       *float32           `db:"blur_score" json:"blur_score"`
	PoseAngles      []byte             `db:"pose_angles" json:"pose_angles"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	SimilarityScore float32            `db:"similarity_score" json:"similarity_score"`
	Confidence_2    float32            `db:"confidence_2" json:"confidence_2"`
	IsManual        *bool              `db:"is_manual" json:"is_manual"`
}

func (q *Queries) GetFaceClusterMembers(ctx context.Context, clusterID int32) ([]GetFaceClusterMembersRow, error) {
	rows, err := q.db.Query(ctx, getFaceClusterMembers, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFaceClusterMembersRow
	for rows.Next() {
		var i GetFaceClusterMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
			&i.SimilarityScore,
			&i.Confidence_2,
			&i.IsManual,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaceDemographics = `-- name: GetFaceDemographics :many
SELECT
    age_group,
    gender,
    ethnicity,
    COUNT(*) as count,
    AVG(confidence) as avg_confidence
FROM face_items
WHERE confidence >= $1
GROUP BY age_group, gender, ethnicity
ORDER BY count DESC
`

type GetFaceDemographicsRow struct {
	AgeGroup      *string `db:"age_group" json:"age_group"`
	Gender        *string `db:"gender" json:"gender"`
	Ethnicity     *string `db:"ethnicity" json:"ethnicity"`
	Count         int64   `db:"count" json:"count"`
	AvgConfidence float64 `db:"avg_confidence" json:"avg_confidence"`
}

func (q *Queries) GetFaceDemographics(ctx context.Context, confidence float32) ([]GetFaceDemographicsRow, error) {
	rows, err := q.db.Query(ctx, getFaceDemographics, confidence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFaceDemographicsRow
	for rows.Next() {
		var i GetFaceDemographicsRow
		if err := rows.Scan(
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Count,
			&i.AvgConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaceEmbeddingsForClustering = `-- name: GetFaceEmbeddingsForClustering :many
SELECT id, asset_id, face_id, embedding, confidence, quality_score
FROM face_items
WHERE embedding IS NOT NULL
AND confidence >= $1
AND quality_score >= $2
ORDER BY quality_score DESC, confidence DESC
LIMIT $3
`

type GetFaceEmbeddingsForClusteringParams struct {
	Confidence   float32  `db:"confidence" json:"confidence"`
	QualityScore *float32 `db:"quality_score" json:"quality_score"`
	Limit        int32    `db:"limit" json:"limit"`
}

type GetFaceEmbeddingsForClusteringRow struct {
	ID           int32            `db:"id" json:"id"`
	AssetID      pgtype.UUID      `db:"asset_id" json:"asset_id"`
	FaceID       *string          `db:"face_id" json:"face_id"`
	Embedding    *pgvector.Vector `db:"embedding" json:"embedding"`
	Confidence   float32          `db:"confidence" json:"confidence"`
	QualityScore *float32         `db:"quality_score" json:"quality_score"`
}

func (q *Queries) GetFaceEmbeddingsForClustering(ctx context.Context, arg GetFaceEmbeddingsForClusteringParams) ([]GetFaceEmbeddingsForClusteringRow, error) {
	rows, err := q.db.Query(ctx, getFaceEmbeddingsForClustering, arg.Confidence, arg.QualityScore, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFaceEmbeddingsForClusteringRow
	for rows.Next() {
		var i GetFaceEmbeddingsForClusteringRow
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.Embedding,
			&i.Confidence,
			&i.QualityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaceItemByID = `-- name: GetFaceItemByID :one
SELECT id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at FROM face_items
WHERE id = $1
`

func (q *Queries) GetFaceItemByID(ctx context.Context, id int32) (FaceItem, error) {
	row := q.db.QueryRow(ctx, getFaceItemByID, id)
	var i FaceItem
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.FaceID,
		&i.BoundingBox,
		&i.Confidence,
		&i.AgeGroup,
		&i.Gender,
		&i.Ethnicity,
		&i.Expression,
		&i.FaceSize,
		&i.FaceImagePath,
		&i.Embedding,
		&i.EmbeddingModel,
		&i.IsPrimary,
		&i.QualityScore,
		&i.BlurScore,
		&i.PoseAngles,
		&i.CreatedAt,
	)
	return i, err
}

const getFaceItemsByAsset = `-- name: GetFaceItemsByAsset :many
SELECT id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at FROM face_items
WHERE asset_id = $1
ORDER BY is_primary DESC, confidence DESC
`

func (q *Queries) GetFaceItemsByAsset(ctx context.Context, assetID pgtype.UUID) ([]FaceItem, error) {
	rows, err := q.db.Query(ctx, getFaceItemsByAsset, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceItem
	for rows.Next() {
		var i FaceItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaceItemsByAssetWithLimit = `-- name: GetFaceItemsByAssetWithLimit :many
SELECT id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at FROM face_items
WHERE asset_id = $1
ORDER BY is_primary DESC, confidence DESC
LIMIT $2
`

type GetFaceItemsByAssetWithLimitParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetFaceItemsByAssetWithLimit(ctx context.Context, arg GetFaceItemsByAssetWithLimitParams) ([]FaceItem, error) {
	rows, err := q.db.Query(ctx, getFaceItemsByAssetWithLimit, arg.AssetID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceItem
	for rows.Next() {
		var i FaceItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFaceResultByAsset = `-- name: GetFaceResultByAsset :one
SELECT asset_id, model_id, total_faces, processing_time_ms, created_at, updated_at FROM face_results
WHERE asset_id = $1
`

func (q *Queries) GetFaceResultByAsset(ctx context.Context, assetID pgtype.UUID) (FaceResult, error) {
	row := q.db.QueryRow(ctx, getFaceResultByAsset, assetID)
	var i FaceResult
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.TotalFaces,
		&i.ProcessingTimeMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFaceStatsByAsset = `-- name: GetFaceStatsByAsset :one
SELECT
    COUNT(*) as total_faces,
    AVG(confidence) as avg_confidence,
    MIN(confidence) as min_confidence,
    MAX(confidence) as max_confidence,
    COUNT(CASE WHEN is_primary = true THEN 1 END) as primary_faces,
    AVG(quality_score) as avg_quality_score,
    AVG(face_size) as avg_face_size
FROM face_items
WHERE asset_id = $1
`

type GetFaceStatsByAssetRow struct {
	TotalFaces      int64       `db:"total_faces" json:"total_faces"`
	AvgConfidence   float64     `db:"avg_confidence" json:"avg_confidence"`
	MinConfidence   interface{} `db:"min_confidence" json:"min_confidence"`
	MaxConfidence   interface{} `db:"max_confidence" json:"max_confidence"`
	PrimaryFaces    int64       `db:"primary_faces" json:"primary_faces"`
	AvgQualityScore float64     `db:"avg_quality_score" json:"avg_quality_score"`
	AvgFaceSize     float64     `db:"avg_face_size" json:"avg_face_size"`
}

func (q *Queries) GetFaceStatsByAsset(ctx context.Context, assetID pgtype.UUID) (GetFaceStatsByAssetRow, error) {
	row := q.db.QueryRow(ctx, getFaceStatsByAsset, assetID)
	var i GetFaceStatsByAssetRow
	err := row.Scan(
		&i.TotalFaces,
		&i.AvgConfidence,
		&i.MinConfidence,
		&i.MaxConfidence,
		&i.PrimaryFaces,
		&i.AvgQualityScore,
		&i.AvgFaceSize,
	)
	return i, err
}

const getFaceStatsByModel = `-- name: GetFaceStatsByModel :many
SELECT
    model_id,
    COUNT(*) as total_assets,
    SUM(total_faces) as total_faces,
    AVG(total_faces) as avg_faces_per_asset,
    MIN(processing_time_ms) as min_processing_time,
    MAX(processing_time_ms) as max_processing_time,
    AVG(processing_time_ms) as avg_processing_time
FROM face_results
GROUP BY model_id
ORDER BY total_assets DESC
`

type GetFaceStatsByModelRow struct {
	ModelID           string      `db:"model_id" json:"model_id"`
	TotalAssets       int64       `db:"total_assets" json:"total_assets"`
	TotalFaces        int64       `db:"total_faces" json:"total_faces"`
	AvgFacesPerAsset  float64     `db:"avg_faces_per_asset" json:"avg_faces_per_asset"`
	MinProcessingTime interface{} `db:"min_processing_time" json:"min_processing_time"`
	MaxProcessingTime interface{} `db:"max_processing_time" json:"max_processing_time"`
	AvgProcessingTime float64     `db:"avg_processing_time" json:"avg_processing_time"`
}

func (q *Queries) GetFaceStatsByModel(ctx context.Context) ([]GetFaceStatsByModelRow, error) {
	rows, err := q.db.Query(ctx, getFaceStatsByModel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFaceStatsByModelRow
	for rows.Next() {
		var i GetFaceStatsByModelRow
		if err := rows.Scan(
			&i.ModelID,
			&i.TotalAssets,
			&i.TotalFaces,
			&i.AvgFacesPerAsset,
			&i.MinProcessingTime,
			&i.MaxProcessingTime,
			&i.AvgProcessingTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFacesByExpression = `-- name: GetFacesByExpression :many
SELECT id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at FROM face_items
WHERE expression = $1
AND confidence >= $2
ORDER BY confidence DESC
LIMIT $3
`

type GetFacesByExpressionParams struct {
	Expression *string `db:"expression" json:"expression"`
	Confidence float32 `db:"confidence" json:"confidence"`
	Limit      int32   `db:"limit" json:"limit"`
}

func (q *Queries) GetFacesByExpression(ctx context.Context, arg GetFacesByExpressionParams) ([]FaceItem, error) {
	rows, err := q.db.Query(ctx, getFacesByExpression, arg.Expression, arg.Confidence, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceItem
	for rows.Next() {
		var i FaceItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryFaces = `-- name: GetPrimaryFaces :many
SELECT id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at FROM face_items
WHERE is_primary = true
AND confidence >= $1
ORDER BY confidence DESC
LIMIT $2
`

type GetPrimaryFacesParams struct {
	Confidence float32 `db:"confidence" json:"confidence"`
	Limit      int32   `db:"limit" json:"limit"`
}

func (q *Queries) GetPrimaryFaces(ctx context.Context, arg GetPrimaryFacesParams) ([]FaceItem, error) {
	rows, err := q.db.Query(ctx, getPrimaryFaces, arg.Confidence, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceItem
	for rows.Next() {
		var i FaceItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarFaces = `-- name: GetSimilarFaces :many
SELECT
    fi.id, fi.asset_id, fi.face_id, fi.bounding_box, fi.confidence, fi.age_group, fi.gender, fi.ethnicity, fi.expression, fi.face_size, fi.face_image_path, fi.embedding, fi.embedding_model, fi.is_primary, fi.quality_score, fi.blur_score, fi.pose_angles, fi.created_at,
    1 - (fi.embedding <=> $1::vector) as similarity
FROM face_items fi
WHERE fi.id != $2
AND fi.embedding IS NOT NULL
AND 1 - (fi.embedding <=> $1::vector) >= $3
ORDER BY similarity DESC
LIMIT $4
`

type GetSimilarFacesParams struct {
	Column1   *pgvector.Vector `db:"column_1" json:"column_1"`
	ID        int32            `db:"id" json:"id"`
	Embedding *pgvector.Vector `db:"embedding" json:"embedding"`
	Limit     int32            `db:"limit" json:"limit"`
}

type GetSimilarFacesRow struct {
	ID             int32              `db:"id" json:"id"`
	AssetID        pgtype.UUID        `db:"asset_id" json:"asset_id"`
	FaceID         *string            `db:"face_id" json:"face_id"`
	BoundingBox    []byte             `db:"bounding_box" json:"bounding_box"`
	Confidence     float32            `db:"confidence" json:"confidence"`
	AgeGroup       *string            `db:"age_group" json:"age_group"`
	Gender         *string            `db:"gender" json:"gender"`
	Ethnicity      *string            `db:"ethnicity" json:"ethnicity"`
	Expression     *string            `db:"expression" json:"expression"`
	FaceSize       *int32             `db:"face_size" json:"face_size"`
	FaceImagePath  *string            `db:"face_image_path" json:"face_image_path"`
	Embedding      *pgvector.Vector   `db:"embedding" json:"embedding"`
	EmbeddingModel *string            `db:"embedding_model" json:"embedding_model"`
	IsPrimary      *bool              `db:"is_primary" json:"is_primary"`
	QualityScore   *float32           `db:"quality_score" json:"quality_score"`
	BlurScore      *float32           `db:"blur_score" json:"blur_score"`
	PoseAngles     []byte             `db:"pose_angles" json:"pose_angles"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	Similarity     int32              `db:"similarity" json:"similarity"`
}

func (q *Queries) GetSimilarFaces(ctx context.Context, arg GetSimilarFacesParams) ([]GetSimilarFacesRow, error) {
	rows, err := q.db.Query(ctx, getSimilarFaces,
		arg.Column1,
		arg.ID,
		arg.Embedding,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarFacesRow
	for rows.Next() {
		var i GetSimilarFacesRow
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopFacesByQuality = `-- name: GetTopFacesByQuality :many
SELECT id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at FROM face_items
WHERE quality_score >= $1
ORDER BY quality_score DESC, confidence DESC
LIMIT $2
`

type GetTopFacesByQualityParams struct {
	QualityScore *float32 `db:"quality_score" json:"quality_score"`
	Limit        int32    `db:"limit" json:"limit"`
}

func (q *Queries) GetTopFacesByQuality(ctx context.Context, arg GetTopFacesByQualityParams) ([]FaceItem, error) {
	rows, err := q.db.Query(ctx, getTopFacesByQuality, arg.QualityScore, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceItem
	for rows.Next() {
		var i FaceItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnclusteredFaces = `-- name: GetUnclusteredFaces :many
SELECT fi.id, fi.asset_id, fi.face_id, fi.bounding_box, fi.confidence, fi.age_group, fi.gender, fi.ethnicity, fi.expression, fi.face_size, fi.face_image_path, fi.embedding, fi.embedding_model, fi.is_primary, fi.quality_score, fi.blur_score, fi.pose_angles, fi.created_at FROM face_items fi
LEFT JOIN face_cluster_members fcm ON fi.id = fcm.face_id
WHERE fcm.face_id IS NULL
AND fi.confidence >= $1
ORDER BY fi.confidence DESC
LIMIT $2
`

type GetUnclusteredFacesParams struct {
	Confidence float32 `db:"confidence" json:"confidence"`
	Limit      int32   `db:"limit" json:"limit"`
}

func (q *Queries) GetUnclusteredFaces(ctx context.Context, arg GetUnclusteredFacesParams) ([]FaceItem, error) {
	rows, err := q.db.Query(ctx, getUnclusteredFaces, arg.Confidence, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FaceItem
	for rows.Next() {
		var i FaceItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.FaceID,
			&i.BoundingBox,
			&i.Confidence,
			&i.AgeGroup,
			&i.Gender,
			&i.Ethnicity,
			&i.Expression,
			&i.FaceSize,
			&i.FaceImagePath,
			&i.Embedding,
			&i.EmbeddingModel,
			&i.IsPrimary,
			&i.QualityScore,
			&i.BlurScore,
			&i.PoseAngles,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeFaceClusters = `-- name: MergeFaceClusters :exec
UPDATE face_cluster_members
SET cluster_id = $1
WHERE cluster_id = $2
`

type MergeFaceClustersParams struct {
	ClusterID   int32 `db:"cluster_id" json:"cluster_id"`
	ClusterID_2 int32 `db:"cluster_id_2" json:"cluster_id_2"`
}

func (q *Queries) MergeFaceClusters(ctx context.Context, arg MergeFaceClustersParams) error {
	_, err := q.db.Exec(ctx, mergeFaceClusters, arg.ClusterID, arg.ClusterID_2)
	return err
}

const searchAssetsByFaceCluster = `-- name: SearchAssetsByFaceCluster :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN face_items fi ON a.asset_id = fi.asset_id
JOIN face_cluster_members fcm ON fi.id = fcm.face_id
WHERE fcm.cluster_id = $1
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByFaceClusterParams struct {
	ClusterID int32 `db:"cluster_id" json:"cluster_id"`
	Offset    int32 `db:"offset" json:"offset"`
	Limit     int32 `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsByFaceCluster(ctx context.Context, arg SearchAssetsByFaceClusterParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByFaceCluster, arg.ClusterID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByFaceID = `-- name: SearchAssetsByFaceID :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN face_items fi ON a.asset_id = fi.asset_id
WHERE fi.face_id = $1
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByFaceIDParams struct {
	FaceID *string `db:"face_id" json:"face_id"`
	Offset int32   `db:"offset" json:"offset"`
	Limit  int32   `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsByFaceID(ctx context.Context, arg SearchAssetsByFaceIDParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByFaceID, arg.FaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFaceCluster = `-- name: UpdateFaceCluster :one
UPDATE face_clusters
SET
    cluster_name = $2,
    confidence_score = $3,
    is_confirmed = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE cluster_id = $1
RETURNING cluster_id, cluster_name, representative_face_id, confidence_score, member_count, is_confirmed, created_at, updated_at
`

type UpdateFaceClusterParams struct {
	ClusterID       int32    `db:"cluster_id" json:"cluster_id"`
	ClusterName     *string  `db:"cluster_name" json:"cluster_name"`
	ConfidenceScore *float32 `db:"confidence_score" json:"confidence_score"`
	IsConfirmed     *bool    `db:"is_confirmed" json:"is_confirmed"`
}

func (q *Queries) UpdateFaceCluster(ctx context.Context, arg UpdateFaceClusterParams) (FaceCluster, error) {
	row := q.db.QueryRow(ctx, updateFaceCluster,
		arg.ClusterID,
		arg.ClusterName,
		arg.ConfidenceScore,
		arg.IsConfirmed,
	)
	var i FaceCluster
	err := row.Scan(
		&i.ClusterID,
		&i.ClusterName,
		&i.RepresentativeFaceID,
		&i.ConfidenceScore,
		&i.MemberCount,
		&i.IsConfirmed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFaceItemEmbedding = `-- name: UpdateFaceItemEmbedding :one
UPDATE face_items
SET
    embedding = $2,
    embedding_model = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, asset_id, face_id, bounding_box, confidence, age_group, gender, ethnicity, expression, face_size, face_image_path, embedding, embedding_model, is_primary, quality_score, blur_score, pose_angles, created_at
`

type UpdateFaceItemEmbeddingParams struct {
	ID             int32            `db:"id" json:"id"`
	Embedding      *pgvector.Vector `db:"embedding" json:"embedding"`
	EmbeddingModel *string          `db:"embedding_model" json:"embedding_model"`
}

func (q *Queries) UpdateFaceItemEmbedding(ctx context.Context, arg UpdateFaceItemEmbeddingParams) (FaceItem, error) {
	row := q.db.QueryRow(ctx, updateFaceItemEmbedding, arg.ID, arg.Embedding, arg.EmbeddingModel)
	var i FaceItem
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.FaceID,
		&i.BoundingBox,
		&i.Confidence,
		&i.AgeGroup,
		&i.Gender,
		&i.Ethnicity,
		&i.Expression,
		&i.FaceSize,
		&i.FaceImagePath,
		&i.Embedding,
		&i.EmbeddingModel,
		&i.IsPrimary,
		&i.QualityScore,
		&i.BlurScore,
		&i.PoseAngles,
		&i.CreatedAt,
	)
	return i, err
}

const updateFaceResultStats = `-- name: UpdateFaceResultStats :exec
UPDATE face_results
SET total_faces = (
    SELECT COUNT(*) FROM face_items fi WHERE fi.asset_id = $1
),
updated_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
`

func (q *Queries) UpdateFaceResultStats(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateFaceResultStats, assetID)
	return err
}
