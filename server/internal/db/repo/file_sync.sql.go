// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: file_sync.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSyncOperationsByStatus = `-- name: CountSyncOperationsByStatus :one
SELECT COUNT(*) FROM sync_operations
WHERE repository_id = $1 AND status = $2
`

type CountSyncOperationsByStatusParams struct {
	RepositoryID pgtype.UUID `db:"repository_id" json:"repository_id"`
	Status       *string     `db:"status" json:"status"`
}

func (q *Queries) CountSyncOperationsByStatus(ctx context.Context, arg CountSyncOperationsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncOperationsByStatus, arg.RepositoryID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFileRecord = `-- name: CreateFileRecord :one

INSERT INTO file_records (
    repository_id,
    file_path,
    file_size,
    mod_time,
    content_hash,
    last_scanned,
    scan_generation
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, repository_id, file_path, file_size, mod_time, content_hash, last_scanned, scan_generation, created_at, updated_at
`

type CreateFileRecordParams struct {
	RepositoryID   pgtype.UUID        `db:"repository_id" json:"repository_id"`
	FilePath       string             `db:"file_path" json:"file_path"`
	FileSize       int64              `db:"file_size" json:"file_size"`
	ModTime        pgtype.Timestamptz `db:"mod_time" json:"mod_time"`
	ContentHash    *string            `db:"content_hash" json:"content_hash"`
	LastScanned    pgtype.Timestamptz `db:"last_scanned" json:"last_scanned"`
	ScanGeneration *int64             `db:"scan_generation" json:"scan_generation"`
}

// File Records Queries
func (q *Queries) CreateFileRecord(ctx context.Context, arg CreateFileRecordParams) (FileRecord, error) {
	row := q.db.QueryRow(ctx, createFileRecord,
		arg.RepositoryID,
		arg.FilePath,
		arg.FileSize,
		arg.ModTime,
		arg.ContentHash,
		arg.LastScanned,
		arg.ScanGeneration,
	)
	var i FileRecord
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.FilePath,
		&i.FileSize,
		&i.ModTime,
		&i.ContentHash,
		&i.LastScanned,
		&i.ScanGeneration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSyncOperation = `-- name: CreateSyncOperation :one

INSERT INTO sync_operations (
    repository_id,
    operation_type,
    files_scanned,
    files_added,
    files_updated,
    files_removed,
    start_time,
    end_time,
    duration_ms,
    status,
    error_message
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at
`

type CreateSyncOperationParams struct {
	RepositoryID  pgtype.UUID        `db:"repository_id" json:"repository_id"`
	OperationType string             `db:"operation_type" json:"operation_type"`
	FilesScanned  *int32             `db:"files_scanned" json:"files_scanned"`
	FilesAdded    *int32             `db:"files_added" json:"files_added"`
	FilesUpdated  *int32             `db:"files_updated" json:"files_updated"`
	FilesRemoved  *int32             `db:"files_removed" json:"files_removed"`
	StartTime     pgtype.Timestamptz `db:"start_time" json:"start_time"`
	EndTime       pgtype.Timestamptz `db:"end_time" json:"end_time"`
	DurationMs    *int64             `db:"duration_ms" json:"duration_ms"`
	Status        *string            `db:"status" json:"status"`
	ErrorMessage  *string            `db:"error_message" json:"error_message"`
}

// Sync Operations Queries
func (q *Queries) CreateSyncOperation(ctx context.Context, arg CreateSyncOperationParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, createSyncOperation,
		arg.RepositoryID,
		arg.OperationType,
		arg.FilesScanned,
		arg.FilesAdded,
		arg.FilesUpdated,
		arg.FilesRemoved,
		arg.StartTime,
		arg.EndTime,
		arg.DurationMs,
		arg.Status,
		arg.ErrorMessage,
	)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.OperationType,
		&i.FilesScanned,
		&i.FilesAdded,
		&i.FilesUpdated,
		&i.FilesRemoved,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllFileRecordsForRepo = `-- name: DeleteAllFileRecordsForRepo :exec
DELETE FROM file_records
WHERE repository_id = $1
`

func (q *Queries) DeleteAllFileRecordsForRepo(ctx context.Context, repositoryID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllFileRecordsForRepo, repositoryID)
	return err
}

const deleteFileRecord = `-- name: DeleteFileRecord :exec
DELETE FROM file_records
WHERE repository_id = $1 AND file_path = $2
`

type DeleteFileRecordParams struct {
	RepositoryID pgtype.UUID `db:"repository_id" json:"repository_id"`
	FilePath     string      `db:"file_path" json:"file_path"`
}

func (q *Queries) DeleteFileRecord(ctx context.Context, arg DeleteFileRecordParams) error {
	_, err := q.db.Exec(ctx, deleteFileRecord, arg.RepositoryID, arg.FilePath)
	return err
}

const deleteOldSyncOperations = `-- name: DeleteOldSyncOperations :exec
DELETE FROM sync_operations
WHERE repository_id = $1
    AND created_at < $2
    AND status != 'running'
`

type DeleteOldSyncOperationsParams struct {
	RepositoryID pgtype.UUID        `db:"repository_id" json:"repository_id"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) DeleteOldSyncOperations(ctx context.Context, arg DeleteOldSyncOperationsParams) error {
	_, err := q.db.Exec(ctx, deleteOldSyncOperations, arg.RepositoryID, arg.CreatedAt)
	return err
}

const deleteOrphanedFileRecords = `-- name: DeleteOrphanedFileRecords :execrows
DELETE FROM file_records
WHERE repository_id = $1 AND scan_generation < $2
`

type DeleteOrphanedFileRecordsParams struct {
	RepositoryID   pgtype.UUID `db:"repository_id" json:"repository_id"`
	ScanGeneration *int64      `db:"scan_generation" json:"scan_generation"`
}

func (q *Queries) DeleteOrphanedFileRecords(ctx context.Context, arg DeleteOrphanedFileRecordsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrphanedFileRecords, arg.RepositoryID, arg.ScanGeneration)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getFailedSyncOperations = `-- name: GetFailedSyncOperations :many
SELECT id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at FROM sync_operations
WHERE repository_id = $1 AND status = 'failed'
ORDER BY start_time DESC
LIMIT $2
`

type GetFailedSyncOperationsParams struct {
	RepositoryID pgtype.UUID `db:"repository_id" json:"repository_id"`
	Limit        int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetFailedSyncOperations(ctx context.Context, arg GetFailedSyncOperationsParams) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, getFailedSyncOperations, arg.RepositoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncOperation
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.OperationType,
			&i.FilesScanned,
			&i.FilesAdded,
			&i.FilesUpdated,
			&i.FilesRemoved,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileRecord = `-- name: GetFileRecord :one
SELECT id, repository_id, file_path, file_size, mod_time, content_hash, last_scanned, scan_generation, created_at, updated_at FROM file_records
WHERE repository_id = $1 AND file_path = $2
`

type GetFileRecordParams struct {
	RepositoryID pgtype.UUID `db:"repository_id" json:"repository_id"`
	FilePath     string      `db:"file_path" json:"file_path"`
}

func (q *Queries) GetFileRecord(ctx context.Context, arg GetFileRecordParams) (FileRecord, error) {
	row := q.db.QueryRow(ctx, getFileRecord, arg.RepositoryID, arg.FilePath)
	var i FileRecord
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.FilePath,
		&i.FileSize,
		&i.ModTime,
		&i.ContentHash,
		&i.LastScanned,
		&i.ScanGeneration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileRecordCount = `-- name: GetFileRecordCount :one
SELECT COUNT(*) FROM file_records
WHERE repository_id = $1
`

func (q *Queries) GetFileRecordCount(ctx context.Context, repositoryID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getFileRecordCount, repositoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFileRecordsByHash = `-- name: GetFileRecordsByHash :many
SELECT id, repository_id, file_path, file_size, mod_time, content_hash, last_scanned, scan_generation, created_at, updated_at FROM file_records
WHERE content_hash = $1
ORDER BY repository_id, file_path
`

func (q *Queries) GetFileRecordsByHash(ctx context.Context, contentHash *string) ([]FileRecord, error) {
	rows, err := q.db.Query(ctx, getFileRecordsByHash, contentHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileRecord
	for rows.Next() {
		var i FileRecord
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.FilePath,
			&i.FileSize,
			&i.ModTime,
			&i.ContentHash,
			&i.LastScanned,
			&i.ScanGeneration,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSyncOperation = `-- name: GetLatestSyncOperation :one
SELECT id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at FROM sync_operations
WHERE repository_id = $1
ORDER BY start_time DESC
LIMIT 1
`

func (q *Queries) GetLatestSyncOperation(ctx context.Context, repositoryID pgtype.UUID) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, getLatestSyncOperation, repositoryID)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.OperationType,
		&i.FilesScanned,
		&i.FilesAdded,
		&i.FilesUpdated,
		&i.FilesRemoved,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestSyncOperationByType = `-- name: GetLatestSyncOperationByType :one
SELECT id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at FROM sync_operations
WHERE repository_id = $1 AND operation_type = $2
ORDER BY start_time DESC
LIMIT 1
`

type GetLatestSyncOperationByTypeParams struct {
	RepositoryID  pgtype.UUID `db:"repository_id" json:"repository_id"`
	OperationType string      `db:"operation_type" json:"operation_type"`
}

func (q *Queries) GetLatestSyncOperationByType(ctx context.Context, arg GetLatestSyncOperationByTypeParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, getLatestSyncOperationByType, arg.RepositoryID, arg.OperationType)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.OperationType,
		&i.FilesScanned,
		&i.FilesAdded,
		&i.FilesUpdated,
		&i.FilesRemoved,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getRunningSyncOperations = `-- name: GetRunningSyncOperations :many
SELECT id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at FROM sync_operations
WHERE repository_id = $1 AND status = 'running'
ORDER BY start_time DESC
`

func (q *Queries) GetRunningSyncOperations(ctx context.Context, repositoryID pgtype.UUID) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, getRunningSyncOperations, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncOperation
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.OperationType,
			&i.FilesScanned,
			&i.FilesAdded,
			&i.FilesUpdated,
			&i.FilesRemoved,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncOperation = `-- name: GetSyncOperation :one
SELECT id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at FROM sync_operations
WHERE id = $1
`

func (q *Queries) GetSyncOperation(ctx context.Context, id int64) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, getSyncOperation, id)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.OperationType,
		&i.FilesScanned,
		&i.FilesAdded,
		&i.FilesUpdated,
		&i.FilesRemoved,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getSyncStatistics = `-- name: GetSyncStatistics :one
SELECT
    COUNT(*) as total_operations,
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_count,
    SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_count,
    SUM(files_scanned) as total_files_scanned,
    SUM(files_added) as total_files_added,
    SUM(files_updated) as total_files_updated,
    SUM(files_removed) as total_files_removed,
    AVG(duration_ms) as avg_duration_ms
FROM sync_operations
WHERE repository_id = $1 AND status = 'completed'
`

type GetSyncStatisticsRow struct {
	TotalOperations   int64   `db:"total_operations" json:"total_operations"`
	CompletedCount    int64   `db:"completed_count" json:"completed_count"`
	FailedCount       int64   `db:"failed_count" json:"failed_count"`
	TotalFilesScanned int64   `db:"total_files_scanned" json:"total_files_scanned"`
	TotalFilesAdded   int64   `db:"total_files_added" json:"total_files_added"`
	TotalFilesUpdated int64   `db:"total_files_updated" json:"total_files_updated"`
	TotalFilesRemoved int64   `db:"total_files_removed" json:"total_files_removed"`
	AvgDurationMs     float64 `db:"avg_duration_ms" json:"avg_duration_ms"`
}

func (q *Queries) GetSyncStatistics(ctx context.Context, repositoryID pgtype.UUID) (GetSyncStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getSyncStatistics, repositoryID)
	var i GetSyncStatisticsRow
	err := row.Scan(
		&i.TotalOperations,
		&i.CompletedCount,
		&i.FailedCount,
		&i.TotalFilesScanned,
		&i.TotalFilesAdded,
		&i.TotalFilesUpdated,
		&i.TotalFilesRemoved,
		&i.AvgDurationMs,
	)
	return i, err
}

const listFileRecords = `-- name: ListFileRecords :many
SELECT id, repository_id, file_path, file_size, mod_time, content_hash, last_scanned, scan_generation, created_at, updated_at FROM file_records
WHERE repository_id = $1
ORDER BY file_path
`

func (q *Queries) ListFileRecords(ctx context.Context, repositoryID pgtype.UUID) ([]FileRecord, error) {
	rows, err := q.db.Query(ctx, listFileRecords, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileRecord
	for rows.Next() {
		var i FileRecord
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.FilePath,
			&i.FileSize,
			&i.ModTime,
			&i.ContentHash,
			&i.LastScanned,
			&i.ScanGeneration,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFileRecordsByGeneration = `-- name: ListFileRecordsByGeneration :many
SELECT id, repository_id, file_path, file_size, mod_time, content_hash, last_scanned, scan_generation, created_at, updated_at FROM file_records
WHERE repository_id = $1 AND scan_generation = $2
ORDER BY file_path
`

type ListFileRecordsByGenerationParams struct {
	RepositoryID   pgtype.UUID `db:"repository_id" json:"repository_id"`
	ScanGeneration *int64      `db:"scan_generation" json:"scan_generation"`
}

func (q *Queries) ListFileRecordsByGeneration(ctx context.Context, arg ListFileRecordsByGenerationParams) ([]FileRecord, error) {
	rows, err := q.db.Query(ctx, listFileRecordsByGeneration, arg.RepositoryID, arg.ScanGeneration)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileRecord
	for rows.Next() {
		var i FileRecord
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.FilePath,
			&i.FileSize,
			&i.ModTime,
			&i.ContentHash,
			&i.LastScanned,
			&i.ScanGeneration,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncOperations = `-- name: ListSyncOperations :many
SELECT id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at FROM sync_operations
WHERE repository_id = $1
ORDER BY start_time DESC
LIMIT $2
`

type ListSyncOperationsParams struct {
	RepositoryID pgtype.UUID `db:"repository_id" json:"repository_id"`
	Limit        int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListSyncOperations(ctx context.Context, arg ListSyncOperationsParams) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, listSyncOperations, arg.RepositoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncOperation
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.OperationType,
			&i.FilesScanned,
			&i.FilesAdded,
			&i.FilesUpdated,
			&i.FilesRemoved,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncOperationsByType = `-- name: ListSyncOperationsByType :many
SELECT id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at FROM sync_operations
WHERE repository_id = $1 AND operation_type = $2
ORDER BY start_time DESC
LIMIT $3
`

type ListSyncOperationsByTypeParams struct {
	RepositoryID  pgtype.UUID `db:"repository_id" json:"repository_id"`
	OperationType string      `db:"operation_type" json:"operation_type"`
	Limit         int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListSyncOperationsByType(ctx context.Context, arg ListSyncOperationsByTypeParams) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, listSyncOperationsByType, arg.RepositoryID, arg.OperationType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncOperation
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.OperationType,
			&i.FilesScanned,
			&i.FilesAdded,
			&i.FilesUpdated,
			&i.FilesRemoved,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileRecord = `-- name: UpdateFileRecord :one
UPDATE file_records
SET
    file_size = $3,
    mod_time = $4,
    content_hash = $5,
    last_scanned = $6,
    scan_generation = $7,
    updated_at = NOW()
WHERE repository_id = $1 AND file_path = $2
RETURNING id, repository_id, file_path, file_size, mod_time, content_hash, last_scanned, scan_generation, created_at, updated_at
`

type UpdateFileRecordParams struct {
	RepositoryID   pgtype.UUID        `db:"repository_id" json:"repository_id"`
	FilePath       string             `db:"file_path" json:"file_path"`
	FileSize       int64              `db:"file_size" json:"file_size"`
	ModTime        pgtype.Timestamptz `db:"mod_time" json:"mod_time"`
	ContentHash    *string            `db:"content_hash" json:"content_hash"`
	LastScanned    pgtype.Timestamptz `db:"last_scanned" json:"last_scanned"`
	ScanGeneration *int64             `db:"scan_generation" json:"scan_generation"`
}

func (q *Queries) UpdateFileRecord(ctx context.Context, arg UpdateFileRecordParams) (FileRecord, error) {
	row := q.db.QueryRow(ctx, updateFileRecord,
		arg.RepositoryID,
		arg.FilePath,
		arg.FileSize,
		arg.ModTime,
		arg.ContentHash,
		arg.LastScanned,
		arg.ScanGeneration,
	)
	var i FileRecord
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.FilePath,
		&i.FileSize,
		&i.ModTime,
		&i.ContentHash,
		&i.LastScanned,
		&i.ScanGeneration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSyncOperation = `-- name: UpdateSyncOperation :one
UPDATE sync_operations
SET
    files_scanned = $2,
    files_added = $3,
    files_updated = $4,
    files_removed = $5,
    end_time = $6,
    duration_ms = $7,
    status = $8,
    error_message = $9
WHERE id = $1
RETURNING id, repository_id, operation_type, files_scanned, files_added, files_updated, files_removed, start_time, end_time, duration_ms, status, error_message, created_at
`

type UpdateSyncOperationParams struct {
	ID           int64              `db:"id" json:"id"`
	FilesScanned *int32             `db:"files_scanned" json:"files_scanned"`
	FilesAdded   *int32             `db:"files_added" json:"files_added"`
	FilesUpdated *int32             `db:"files_updated" json:"files_updated"`
	FilesRemoved *int32             `db:"files_removed" json:"files_removed"`
	EndTime      pgtype.Timestamptz `db:"end_time" json:"end_time"`
	DurationMs   *int64             `db:"duration_ms" json:"duration_ms"`
	Status       *string            `db:"status" json:"status"`
	ErrorMessage *string            `db:"error_message" json:"error_message"`
}

func (q *Queries) UpdateSyncOperation(ctx context.Context, arg UpdateSyncOperationParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, updateSyncOperation,
		arg.ID,
		arg.FilesScanned,
		arg.FilesAdded,
		arg.FilesUpdated,
		arg.FilesRemoved,
		arg.EndTime,
		arg.DurationMs,
		arg.Status,
		arg.ErrorMessage,
	)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.OperationType,
		&i.FilesScanned,
		&i.FilesAdded,
		&i.FilesUpdated,
		&i.FilesRemoved,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const upsertFileRecord = `-- name: UpsertFileRecord :one
INSERT INTO file_records (
    repository_id,
    file_path,
    file_size,
    mod_time,
    content_hash,
    last_scanned,
    scan_generation
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (repository_id, file_path)
DO UPDATE SET
    file_size = EXCLUDED.file_size,
    mod_time = EXCLUDED.mod_time,
    content_hash = EXCLUDED.content_hash,
    last_scanned = EXCLUDED.last_scanned,
    scan_generation = EXCLUDED.scan_generation,
    updated_at = NOW()
RETURNING id, repository_id, file_path, file_size, mod_time, content_hash, last_scanned, scan_generation, created_at, updated_at
`

type UpsertFileRecordParams struct {
	RepositoryID   pgtype.UUID        `db:"repository_id" json:"repository_id"`
	FilePath       string             `db:"file_path" json:"file_path"`
	FileSize       int64              `db:"file_size" json:"file_size"`
	ModTime        pgtype.Timestamptz `db:"mod_time" json:"mod_time"`
	ContentHash    *string            `db:"content_hash" json:"content_hash"`
	LastScanned    pgtype.Timestamptz `db:"last_scanned" json:"last_scanned"`
	ScanGeneration *int64             `db:"scan_generation" json:"scan_generation"`
}

func (q *Queries) UpsertFileRecord(ctx context.Context, arg UpsertFileRecordParams) (FileRecord, error) {
	row := q.db.QueryRow(ctx, upsertFileRecord,
		arg.RepositoryID,
		arg.FilePath,
		arg.FileSize,
		arg.ModTime,
		arg.ContentHash,
		arg.LastScanned,
		arg.ScanGeneration,
	)
	var i FileRecord
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.FilePath,
		&i.FileSize,
		&i.ModTime,
		&i.ContentHash,
		&i.LastScanned,
		&i.ScanGeneration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
