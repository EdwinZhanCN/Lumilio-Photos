// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: albums.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
	"server/internal/db/dbtypes"
)

const createAlbum = `-- name: CreateAlbum :one
INSERT INTO albums (user_id, album_name, description, cover_asset_id)
VALUES ($1, $2, $3, $4)
RETURNING album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id
`

type CreateAlbumParams struct {
	UserID       int32       `db:"user_id" json:"user_id"`
	AlbumName    string      `db:"album_name" json:"album_name"`
	Description  *string     `db:"description" json:"description"`
	CoverAssetID pgtype.UUID `db:"cover_asset_id" json:"cover_asset_id"`
}

func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) (Album, error) {
	row := q.db.QueryRow(ctx, createAlbum,
		arg.UserID,
		arg.AlbumName,
		arg.Description,
		arg.CoverAssetID,
	)
	var i Album
	err := row.Scan(
		&i.AlbumID,
		&i.UserID,
		&i.AlbumName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.CoverAssetID,
	)
	return i, err
}

const deleteAlbum = `-- name: DeleteAlbum :exec
DELETE FROM albums WHERE album_id = $1
`

func (q *Queries) DeleteAlbum(ctx context.Context, albumID int32) error {
	_, err := q.db.Exec(ctx, deleteAlbum, albumID)
	return err
}

const getAlbumAssetCount = `-- name: GetAlbumAssetCount :one
SELECT COUNT(*) as count
FROM album_assets aa
JOIN assets a ON aa.asset_id = a.asset_id
WHERE aa.album_id = $1 AND a.is_deleted = false
`

func (q *Queries) GetAlbumAssetCount(ctx context.Context, albumID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getAlbumAssetCount, albumID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAlbumAssets = `-- name: GetAlbumAssets :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.embedding, aa.position, aa.added_time
FROM assets a
JOIN album_assets aa ON a.asset_id = aa.asset_id
WHERE aa.album_id = $1 AND a.is_deleted = false
ORDER BY aa.position ASC, aa.added_time ASC
`

type GetAlbumAssetsRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      string                   `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Embedding        pgvector_go.Vector       `db:"embedding" json:"embedding"`
	Position         *int32                   `db:"position" json:"position"`
	AddedTime        pgtype.Timestamptz       `db:"added_time" json:"added_time"`
}

func (q *Queries) GetAlbumAssets(ctx context.Context, albumID int32) ([]GetAlbumAssetsRow, error) {
	rows, err := q.db.Query(ctx, getAlbumAssets, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumAssetsRow
	for rows.Next() {
		var i GetAlbumAssetsRow
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Embedding,
			&i.Position,
			&i.AddedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumByID = `-- name: GetAlbumByID :one
SELECT album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id FROM albums WHERE album_id = $1
`

func (q *Queries) GetAlbumByID(ctx context.Context, albumID int32) (Album, error) {
	row := q.db.QueryRow(ctx, getAlbumByID, albumID)
	var i Album
	err := row.Scan(
		&i.AlbumID,
		&i.UserID,
		&i.AlbumName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.CoverAssetID,
	)
	return i, err
}

const getAlbumsByUser = `-- name: GetAlbumsByUser :many
SELECT album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id FROM albums
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAlbumsByUserParams struct {
	UserID int32 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAlbumsByUser(ctx context.Context, arg GetAlbumsByUserParams) ([]Album, error) {
	rows, err := q.db.Query(ctx, getAlbumsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.AlbumID,
			&i.UserID,
			&i.AlbumName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.CoverAssetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetAlbums = `-- name: GetAssetAlbums :many
SELECT al.album_id, al.user_id, al.album_name, al.created_at, al.updated_at, al.description, al.cover_asset_id, aa.position, aa.added_time
FROM albums al
JOIN album_assets aa ON al.album_id = aa.album_id
WHERE aa.asset_id = $1
ORDER BY al.album_name ASC
`

type GetAssetAlbumsRow struct {
	AlbumID      int32              `db:"album_id" json:"album_id"`
	UserID       int32              `db:"user_id" json:"user_id"`
	AlbumName    string             `db:"album_name" json:"album_name"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Description  *string            `db:"description" json:"description"`
	CoverAssetID pgtype.UUID        `db:"cover_asset_id" json:"cover_asset_id"`
	Position     *int32             `db:"position" json:"position"`
	AddedTime    pgtype.Timestamptz `db:"added_time" json:"added_time"`
}

func (q *Queries) GetAssetAlbums(ctx context.Context, assetID pgtype.UUID) ([]GetAssetAlbumsRow, error) {
	rows, err := q.db.Query(ctx, getAssetAlbums, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetAlbumsRow
	for rows.Next() {
		var i GetAssetAlbumsRow
		if err := rows.Scan(
			&i.AlbumID,
			&i.UserID,
			&i.AlbumName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.CoverAssetID,
			&i.Position,
			&i.AddedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlbum = `-- name: UpdateAlbum :one
UPDATE albums
SET album_name = $2, description = $3, cover_asset_id = $4, updated_at = CURRENT_TIMESTAMP
WHERE album_id = $1
RETURNING album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id
`

type UpdateAlbumParams struct {
	AlbumID      int32       `db:"album_id" json:"album_id"`
	AlbumName    string      `db:"album_name" json:"album_name"`
	Description  *string     `db:"description" json:"description"`
	CoverAssetID pgtype.UUID `db:"cover_asset_id" json:"cover_asset_id"`
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) (Album, error) {
	row := q.db.QueryRow(ctx, updateAlbum,
		arg.AlbumID,
		arg.AlbumName,
		arg.Description,
		arg.CoverAssetID,
	)
	var i Album
	err := row.Scan(
		&i.AlbumID,
		&i.UserID,
		&i.AlbumName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.CoverAssetID,
	)
	return i, err
}

const updateAssetPositionInAlbum = `-- name: UpdateAssetPositionInAlbum :exec
UPDATE album_assets
SET position = $3
WHERE album_id = $1 AND asset_id = $2
`

type UpdateAssetPositionInAlbumParams struct {
	AlbumID  int32       `db:"album_id" json:"album_id"`
	AssetID  pgtype.UUID `db:"asset_id" json:"asset_id"`
	Position *int32      `db:"position" json:"position"`
}

func (q *Queries) UpdateAssetPositionInAlbum(ctx context.Context, arg UpdateAssetPositionInAlbumParams) error {
	_, err := q.db.Exec(ctx, updateAssetPositionInAlbum, arg.AlbumID, arg.AssetID, arg.Position)
	return err
}
