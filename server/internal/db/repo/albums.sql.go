// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: albums.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"server/internal/db/dbtypes"
)

const createAlbum = `-- name: CreateAlbum :one
INSERT INTO albums (user_id, album_name, description, cover_asset_id)
VALUES ($1, $2, $3, $4)
RETURNING album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id
`

type CreateAlbumParams struct {
	UserID       int32       `db:"user_id" json:"user_id"`
	AlbumName    string      `db:"album_name" json:"album_name"`
	Description  *string     `db:"description" json:"description"`
	CoverAssetID pgtype.UUID `db:"cover_asset_id" json:"cover_asset_id"`
}

func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) (Album, error) {
	row := q.db.QueryRow(ctx, createAlbum,
		arg.UserID,
		arg.AlbumName,
		arg.Description,
		arg.CoverAssetID,
	)
	var i Album
	err := row.Scan(
		&i.AlbumID,
		&i.UserID,
		&i.AlbumName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.CoverAssetID,
	)
	return i, err
}

const deleteAlbum = `-- name: DeleteAlbum :exec
DELETE FROM albums WHERE album_id = $1
`

func (q *Queries) DeleteAlbum(ctx context.Context, albumID int32) error {
	_, err := q.db.Exec(ctx, deleteAlbum, albumID)
	return err
}

const filterAlbumAssets = `-- name: FilterAlbumAssets :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN album_assets aa ON a.asset_id = aa.asset_id
WHERE aa.album_id = $1
  AND a.is_deleted = false
  AND ($2::text IS NULL OR a.type = $2)
  AND ($3::text IS NULL OR
    CASE $4::text
      WHEN 'contains' THEN a.original_filename ILIKE '%' || $3 || '%'
      WHEN 'matches' THEN a.original_filename ILIKE $3
      WHEN 'startswith' THEN a.original_filename ILIKE $3 || '%'
      WHEN 'endswith' THEN a.original_filename ILIKE '%' || $3
      ELSE true
    END
  )
  AND ($5::timestamptz IS NULL OR a.upload_time >= $5)
  AND ($6::timestamptz IS NULL OR a.upload_time <= $6)
  AND ($7::boolean IS NULL OR
    CASE
      WHEN $7 = true THEN (a.specific_metadata->>'is_raw')::boolean = true
      WHEN $7 = false THEN (a.specific_metadata->>'is_raw')::boolean = false OR a.specific_metadata->>'is_raw' IS NULL
      ELSE true
    END
  )
  AND ($8::integer IS NULL OR
    CASE
      WHEN $8 = 0 THEN a.rating IS NULL
      ELSE a.rating = $8
    END
  )
  AND ($9::boolean IS NULL OR a.liked = $9)
  AND ($10::text IS NULL OR a.specific_metadata->>'camera_model' = $10)
  AND ($11::text IS NULL OR a.specific_metadata->>'lens_model' = $11)
ORDER BY aa.position ASC, aa.added_time DESC
LIMIT $13 OFFSET $12
`

type FilterAlbumAssetsParams struct {
	AlbumID      int32              `db:"album_id" json:"album_id"`
	AssetType    *string            `db:"asset_type" json:"asset_type"`
	FilenameVal  *string            `db:"filename_val" json:"filename_val"`
	FilenameMode *string            `db:"filename_mode" json:"filename_mode"`
	DateFrom     pgtype.Timestamptz `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamptz `db:"date_to" json:"date_to"`
	IsRaw        *bool              `db:"is_raw" json:"is_raw"`
	Rating       *int32             `db:"rating" json:"rating"`
	Liked        *bool              `db:"liked" json:"liked"`
	CameraModel  *string            `db:"camera_model" json:"camera_model"`
	LensModel    *string            `db:"lens_model" json:"lens_model"`
	Offset       int32              `db:"offset" json:"offset"`
	Limit        int32              `db:"limit" json:"limit"`
}

func (q *Queries) FilterAlbumAssets(ctx context.Context, arg FilterAlbumAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, filterAlbumAssets,
		arg.AlbumID,
		arg.AssetType,
		arg.FilenameVal,
		arg.FilenameMode,
		arg.DateFrom,
		arg.DateTo,
		arg.IsRaw,
		arg.Rating,
		arg.Liked,
		arg.CameraModel,
		arg.LensModel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumAssetCount = `-- name: GetAlbumAssetCount :one
SELECT COUNT(*) as count
FROM album_assets aa
JOIN assets a ON aa.asset_id = a.asset_id
WHERE aa.album_id = $1 AND a.is_deleted = false
`

func (q *Queries) GetAlbumAssetCount(ctx context.Context, albumID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getAlbumAssetCount, albumID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAlbumAssets = `-- name: GetAlbumAssets :many
SELECT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status, aa.position, aa.added_time
FROM assets a
JOIN album_assets aa ON a.asset_id = aa.asset_id
WHERE aa.album_id = $1 AND a.is_deleted = false
ORDER BY aa.position ASC, aa.added_time ASC
`

type GetAlbumAssetsRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      *string                  `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating           *int32                   `db:"rating" json:"rating"`
	Liked            *bool                    `db:"liked" json:"liked"`
	RepositoryID     pgtype.UUID              `db:"repository_id" json:"repository_id"`
	Status           []byte                   `db:"status" json:"status"`
	Position         *int32                   `db:"position" json:"position"`
	AddedTime        pgtype.Timestamptz       `db:"added_time" json:"added_time"`
}

func (q *Queries) GetAlbumAssets(ctx context.Context, albumID int32) ([]GetAlbumAssetsRow, error) {
	rows, err := q.db.Query(ctx, getAlbumAssets, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumAssetsRow
	for rows.Next() {
		var i GetAlbumAssetsRow
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
			&i.Position,
			&i.AddedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumByID = `-- name: GetAlbumByID :one
SELECT album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id FROM albums WHERE album_id = $1
`

func (q *Queries) GetAlbumByID(ctx context.Context, albumID int32) (Album, error) {
	row := q.db.QueryRow(ctx, getAlbumByID, albumID)
	var i Album
	err := row.Scan(
		&i.AlbumID,
		&i.UserID,
		&i.AlbumName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.CoverAssetID,
	)
	return i, err
}

const getAlbumsByUser = `-- name: GetAlbumsByUser :many
SELECT album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id FROM albums
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAlbumsByUserParams struct {
	UserID int32 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAlbumsByUser(ctx context.Context, arg GetAlbumsByUserParams) ([]Album, error) {
	rows, err := q.db.Query(ctx, getAlbumsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.AlbumID,
			&i.UserID,
			&i.AlbumName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.CoverAssetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetAlbums = `-- name: GetAssetAlbums :many
SELECT al.album_id, al.user_id, al.album_name, al.created_at, al.updated_at, al.description, al.cover_asset_id, aa.position, aa.added_time
FROM albums al
JOIN album_assets aa ON al.album_id = aa.album_id
WHERE aa.asset_id = $1
ORDER BY al.album_name ASC
`

type GetAssetAlbumsRow struct {
	AlbumID      int32              `db:"album_id" json:"album_id"`
	UserID       int32              `db:"user_id" json:"user_id"`
	AlbumName    string             `db:"album_name" json:"album_name"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Description  *string            `db:"description" json:"description"`
	CoverAssetID pgtype.UUID        `db:"cover_asset_id" json:"cover_asset_id"`
	Position     *int32             `db:"position" json:"position"`
	AddedTime    pgtype.Timestamptz `db:"added_time" json:"added_time"`
}

func (q *Queries) GetAssetAlbums(ctx context.Context, assetID pgtype.UUID) ([]GetAssetAlbumsRow, error) {
	rows, err := q.db.Query(ctx, getAssetAlbums, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetAlbumsRow
	for rows.Next() {
		var i GetAssetAlbumsRow
		if err := rows.Scan(
			&i.AlbumID,
			&i.UserID,
			&i.AlbumName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.CoverAssetID,
			&i.Position,
			&i.AddedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlbum = `-- name: UpdateAlbum :one
UPDATE albums
SET album_name = $2, description = $3, cover_asset_id = $4, updated_at = CURRENT_TIMESTAMP
WHERE album_id = $1
RETURNING album_id, user_id, album_name, created_at, updated_at, description, cover_asset_id
`

type UpdateAlbumParams struct {
	AlbumID      int32       `db:"album_id" json:"album_id"`
	AlbumName    string      `db:"album_name" json:"album_name"`
	Description  *string     `db:"description" json:"description"`
	CoverAssetID pgtype.UUID `db:"cover_asset_id" json:"cover_asset_id"`
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) (Album, error) {
	row := q.db.QueryRow(ctx, updateAlbum,
		arg.AlbumID,
		arg.AlbumName,
		arg.Description,
		arg.CoverAssetID,
	)
	var i Album
	err := row.Scan(
		&i.AlbumID,
		&i.UserID,
		&i.AlbumName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.CoverAssetID,
	)
	return i, err
}

const updateAssetPositionInAlbum = `-- name: UpdateAssetPositionInAlbum :exec
UPDATE album_assets
SET position = $3
WHERE album_id = $1 AND asset_id = $2
`

type UpdateAssetPositionInAlbumParams struct {
	AlbumID  int32       `db:"album_id" json:"album_id"`
	AssetID  pgtype.UUID `db:"asset_id" json:"asset_id"`
	Position *int32      `db:"position" json:"position"`
}

func (q *Queries) UpdateAssetPositionInAlbum(ctx context.Context, arg UpdateAssetPositionInAlbumParams) error {
	_, err := q.db.Exec(ctx, updateAssetPositionInAlbum, arg.AlbumID, arg.AssetID, arg.Position)
	return err
}
