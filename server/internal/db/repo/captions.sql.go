// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: captions.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCaption = `-- name: CreateCaption :one
INSERT INTO captions (asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at
`

type CreateCaptionParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	ModelID          string      `db:"model_id" json:"model_id"`
	Description      string      `db:"description" json:"description"`
	Summary          *string     `db:"summary" json:"summary"`
	Confidence       *float32    `db:"confidence" json:"confidence"`
	TokensGenerated  *int32      `db:"tokens_generated" json:"tokens_generated"`
	ProcessingTimeMs *int32      `db:"processing_time_ms" json:"processing_time_ms"`
	PromptUsed       *string     `db:"prompt_used" json:"prompt_used"`
	FinishReason     *string     `db:"finish_reason" json:"finish_reason"`
}

func (q *Queries) CreateCaption(ctx context.Context, arg CreateCaptionParams) (Caption, error) {
	row := q.db.QueryRow(ctx, createCaption,
		arg.AssetID,
		arg.ModelID,
		arg.Description,
		arg.Summary,
		arg.Confidence,
		arg.TokensGenerated,
		arg.ProcessingTimeMs,
		arg.PromptUsed,
		arg.FinishReason,
	)
	var i Caption
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.Description,
		&i.Summary,
		&i.Confidence,
		&i.TokensGenerated,
		&i.ProcessingTimeMs,
		&i.PromptUsed,
		&i.FinishReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCaptionByAsset = `-- name: DeleteCaptionByAsset :exec
DELETE FROM captions WHERE asset_id = $1
`

func (q *Queries) DeleteCaptionByAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCaptionByAsset, assetID)
	return err
}

const getCaptionByAsset = `-- name: GetCaptionByAsset :one
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM captions
WHERE asset_id = $1
`

func (q *Queries) GetCaptionByAsset(ctx context.Context, assetID pgtype.UUID) (Caption, error) {
	row := q.db.QueryRow(ctx, getCaptionByAsset, assetID)
	var i Caption
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.Description,
		&i.Summary,
		&i.Confidence,
		&i.TokensGenerated,
		&i.ProcessingTimeMs,
		&i.PromptUsed,
		&i.FinishReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCaptionStatsByModel = `-- name: GetCaptionStatsByModel :many
SELECT
    model_id,
    COUNT(*) as total_descriptions,
    AVG(tokens_generated) as avg_tokens,
    MIN(tokens_generated) as min_tokens,
    MAX(tokens_generated) as max_tokens,
    AVG(processing_time_ms) as avg_processing_time,
    MIN(processing_time_ms) as min_processing_time,
    MAX(processing_time_ms) as max_processing_time,
    AVG(confidence) as avg_confidence
FROM captions
GROUP BY model_id
ORDER BY total_descriptions DESC
`

type GetCaptionStatsByModelRow struct {
	ModelID           string      `db:"model_id" json:"model_id"`
	TotalDescriptions int64       `db:"total_descriptions" json:"total_descriptions"`
	AvgTokens         float64     `db:"avg_tokens" json:"avg_tokens"`
	MinTokens         interface{} `db:"min_tokens" json:"min_tokens"`
	MaxTokens         interface{} `db:"max_tokens" json:"max_tokens"`
	AvgProcessingTime float64     `db:"avg_processing_time" json:"avg_processing_time"`
	MinProcessingTime interface{} `db:"min_processing_time" json:"min_processing_time"`
	MaxProcessingTime interface{} `db:"max_processing_time" json:"max_processing_time"`
	AvgConfidence     float64     `db:"avg_confidence" json:"avg_confidence"`
}

func (q *Queries) GetCaptionStatsByModel(ctx context.Context) ([]GetCaptionStatsByModelRow, error) {
	rows, err := q.db.Query(ctx, getCaptionStatsByModel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCaptionStatsByModelRow
	for rows.Next() {
		var i GetCaptionStatsByModelRow
		if err := rows.Scan(
			&i.ModelID,
			&i.TotalDescriptions,
			&i.AvgTokens,
			&i.MinTokens,
			&i.MaxTokens,
			&i.AvgProcessingTime,
			&i.MinProcessingTime,
			&i.MaxProcessingTime,
			&i.AvgConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCaptionsByModel = `-- name: GetCaptionsByModel :many
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM captions
WHERE model_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCaptionsByModelParams struct {
	ModelID string `db:"model_id" json:"model_id"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetCaptionsByModel(ctx context.Context, arg GetCaptionsByModelParams) ([]Caption, error) {
	rows, err := q.db.Query(ctx, getCaptionsByModel, arg.ModelID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Caption
	for rows.Next() {
		var i Caption
		if err := rows.Scan(
			&i.AssetID,
			&i.ModelID,
			&i.Description,
			&i.Summary,
			&i.Confidence,
			&i.TokensGenerated,
			&i.ProcessingTimeMs,
			&i.PromptUsed,
			&i.FinishReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLongCaptions = `-- name: GetLongCaptions :many
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM captions
WHERE LENGTH(description) > $1::int
ORDER BY LENGTH(description) DESC
LIMIT $2
`

type GetLongCaptionsParams struct {
	MinLength int32 `db:"min_length" json:"min_length"`
	RowLimit  int32 `db:"row_limit" json:"row_limit"`
}

func (q *Queries) GetLongCaptions(ctx context.Context, arg GetLongCaptionsParams) ([]Caption, error) {
	rows, err := q.db.Query(ctx, getLongCaptions, arg.MinLength, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Caption
	for rows.Next() {
		var i Caption
		if err := rows.Scan(
			&i.AssetID,
			&i.ModelID,
			&i.Description,
			&i.Summary,
			&i.Confidence,
			&i.TokensGenerated,
			&i.ProcessingTimeMs,
			&i.PromptUsed,
			&i.FinishReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCaptionsByTokens = `-- name: GetTopCaptionsByTokens :many
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM captions
ORDER BY tokens_generated DESC
LIMIT $1
`

func (q *Queries) GetTopCaptionsByTokens(ctx context.Context, limit int32) ([]Caption, error) {
	rows, err := q.db.Query(ctx, getTopCaptionsByTokens, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Caption
	for rows.Next() {
		var i Caption
		if err := rows.Scan(
			&i.AssetID,
			&i.ModelID,
			&i.Description,
			&i.Summary,
			&i.Confidence,
			&i.TokensGenerated,
			&i.ProcessingTimeMs,
			&i.PromptUsed,
			&i.FinishReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByCaption = `-- name: SearchAssetsByCaption :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN captions d ON a.asset_id = d.asset_id
WHERE to_tsvector('english', d.description) @@ plainto_tsquery('english', $1)
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByCaptionParams struct {
	PlaintoTsquery string `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32  `db:"offset" json:"offset"`
	Limit          int32  `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsByCaption(ctx context.Context, arg SearchAssetsByCaptionParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByCaption, arg.PlaintoTsquery, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByCaptionSummary = `-- name: SearchAssetsByCaptionSummary :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN captions d ON a.asset_id = d.asset_id
WHERE to_tsvector('english', d.summary) @@ plainto_tsquery('english', $1)
AND d.summary IS NOT NULL
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByCaptionSummaryParams struct {
	PlaintoTsquery string `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32  `db:"offset" json:"offset"`
	Limit          int32  `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsByCaptionSummary(ctx context.Context, arg SearchAssetsByCaptionSummaryParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByCaptionSummary, arg.PlaintoTsquery, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByCaptionWithConfidence = `-- name: SearchAssetsByCaptionWithConfidence :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN captions d ON a.asset_id = d.asset_id
WHERE to_tsvector('english', d.description) @@ plainto_tsquery('english', $1)
AND d.confidence >= $4
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByCaptionWithConfidenceParams struct {
	PlaintoTsquery string   `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32    `db:"offset" json:"offset"`
	Limit          int32    `db:"limit" json:"limit"`
	Confidence     *float32 `db:"confidence" json:"confidence"`
}

func (q *Queries) SearchAssetsByCaptionWithConfidence(ctx context.Context, arg SearchAssetsByCaptionWithConfidenceParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByCaptionWithConfidence,
		arg.PlaintoTsquery,
		arg.Offset,
		arg.Limit,
		arg.Confidence,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCaption = `-- name: UpdateCaption :one
UPDATE captions
SET
    model_id = $2,
    description = $3,
    summary = $4,
    confidence = $5,
    tokens_generated = $6,
    processing_time_ms = $7,
    prompt_used = $8,
    finish_reason = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
RETURNING asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at
`

type UpdateCaptionParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	ModelID          string      `db:"model_id" json:"model_id"`
	Description      string      `db:"description" json:"description"`
	Summary          *string     `db:"summary" json:"summary"`
	Confidence       *float32    `db:"confidence" json:"confidence"`
	TokensGenerated  *int32      `db:"tokens_generated" json:"tokens_generated"`
	ProcessingTimeMs *int32      `db:"processing_time_ms" json:"processing_time_ms"`
	PromptUsed       *string     `db:"prompt_used" json:"prompt_used"`
	FinishReason     *string     `db:"finish_reason" json:"finish_reason"`
}

func (q *Queries) UpdateCaption(ctx context.Context, arg UpdateCaptionParams) (Caption, error) {
	row := q.db.QueryRow(ctx, updateCaption,
		arg.AssetID,
		arg.ModelID,
		arg.Description,
		arg.Summary,
		arg.Confidence,
		arg.TokensGenerated,
		arg.ProcessingTimeMs,
		arg.PromptUsed,
		arg.FinishReason,
	)
	var i Caption
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.Description,
		&i.Summary,
		&i.Confidence,
		&i.TokensGenerated,
		&i.ProcessingTimeMs,
		&i.PromptUsed,
		&i.FinishReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCaptionStats = `-- name: UpdateCaptionStats :exec
UPDATE captions
SET
    tokens_generated = (
        SELECT LENGTH(description) / 4.0 -- Approximate token count (rough estimate: 1 token â‰ˆ 4 characters)
        WHERE asset_id = $1
    )
WHERE asset_id = $1
`

func (q *Queries) UpdateCaptionStats(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateCaptionStats, assetID)
	return err
}
