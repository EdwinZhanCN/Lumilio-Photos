// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: relationships.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"server/internal/db/dbtypes"
)

const getAssetWithRelations = `-- name: GetAssetWithRelations :one
SELECT
    a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'thumbnail_id', t.thumbnail_id,
                'size', t.size,
                'storage_path', t.storage_path,
                'mime_type', t.mime_type
            )
        ) FILTER (WHERE t.thumbnail_id IS NOT NULL),
        '[]'
    ) as thumbnails,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'tag_id', tg.tag_id,
                'tag_name', tg.tag_name,
                'confidence', at.confidence
            )
        ) FILTER (WHERE tg.tag_id IS NOT NULL),
        '[]'
    ) as tags,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'album_id', al.album_id,
                'album_name', al.album_name,
                'position', aa.position,
                'added_time', aa.added_time
            )
        ) FILTER (WHERE al.album_id IS NOT NULL),
        '[]'
    ) as albums,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'label', sp.label,
                'score', sp.score
            )
        ) FILTER (WHERE sp.label IS NOT NULL),
        '[]'
    ) as species_predictions,
    CASE
        WHEN ocr.asset_id IS NOT NULL THEN jsonb_build_object(
            'model_id', ocr.model_id,
            'total_count', ocr.total_count,
            'processing_time_ms', ocr.processing_time_ms,
            'created_at', ocr.created_at,
            'updated_at', ocr.updated_at,
            'text_items', COALESCE(
                json_agg(
                    jsonb_build_object(
                        'id', ocr_ti.id,
                        'text_content', ocr_ti.text_content,
                        'confidence', ocr_ti.confidence,
                        'bounding_box', ocr_ti.bounding_box,
                        'text_length', ocr_ti.text_length,
                        'area_pixels', ocr_ti.area_pixels
                    )
                ) FILTER (WHERE ocr_ti.id IS NOT NULL),
                '[]'::json
            )
        )
        ELSE NULL
    END as ocr_result,
    CASE
        WHEN fr.asset_id IS NOT NULL THEN jsonb_build_object(
            'model_id', fr.model_id,
            'total_faces', fr.total_faces,
            'processing_time_ms', fr.processing_time_ms,
            'created_at', fr.created_at,
            'updated_at', fr.updated_at,
            'faces', COALESCE(
                json_agg(
                    jsonb_build_object(
                        'id', fi.id,
                        'face_id', fi.face_id,
                        'bounding_box', fi.bounding_box,
                        'confidence', fi.confidence,
                        'age_group', fi.age_group,
                        'gender', fi.gender,
                        'ethnicity', fi.ethnicity,
                        'expression', fi.expression,
                        'is_primary', fi.is_primary,
                        'cluster_id', fcm.cluster_id,
                        'cluster_name', fc.cluster_name
                    )
                ) FILTER (WHERE fi.id IS NOT NULL),
                '[]'::json
            )
        )
        ELSE NULL
    END as face_result,
    CASE
        WHEN cap.asset_id IS NOT NULL THEN jsonb_build_object(
            'model_id', cap.model_id,
            'description', cap.description,
            'summary', cap.summary,
            'confidence', cap.confidence,
            'tokens_generated', cap.tokens_generated,
            'processing_time_ms', cap.processing_time_ms,
            'prompt_used', cap.prompt_used,
            'finish_reason', cap.finish_reason,
            'created_at', cap.created_at,
            'updated_at', cap.updated_at
        )
        ELSE NULL
    END as caption
FROM assets a
LEFT JOIN thumbnails t ON a.asset_id = t.asset_id
LEFT JOIN asset_tags at ON a.asset_id = at.asset_id
LEFT JOIN tags tg ON at.tag_id = tg.tag_id
LEFT JOIN album_assets aa ON a.asset_id = aa.asset_id
LEFT JOIN albums al ON aa.album_id = al.album_id
LEFT JOIN species_predictions sp ON a.asset_id = sp.asset_id
LEFT JOIN ocr_results ocr ON a.asset_id = ocr.asset_id
LEFT JOIN ocr_text_items ocr_ti ON a.asset_id = ocr_ti.asset_id
LEFT JOIN face_results fr ON a.asset_id = fr.asset_id
LEFT JOIN face_items fi ON a.asset_id = fi.asset_id
LEFT JOIN face_cluster_members fcm ON fi.id = fcm.face_id
LEFT JOIN face_clusters fc ON fcm.cluster_id = fc.cluster_id
LEFT JOIN captions cap ON a.asset_id = cap.asset_id
WHERE a.asset_id = $1 AND a.is_deleted = false
GROUP BY a.asset_id, a.rating, a.liked,
         ocr.asset_id, ocr.model_id, ocr.total_count, ocr.processing_time_ms, ocr.created_at, ocr.updated_at,
         fr.asset_id, fr.model_id, fr.total_faces, fr.processing_time_ms, fr.created_at, fr.updated_at,
         cap.asset_id, cap.model_id, cap.description, cap.summary,
         cap.confidence, cap.tokens_generated, cap.processing_time_ms,
         cap.prompt_used, cap.finish_reason, cap.created_at, cap.updated_at
`

type GetAssetWithRelationsRow struct {
	AssetID            pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID            *int32                   `db:"owner_id" json:"owner_id"`
	Type               string                   `db:"type" json:"type"`
	OriginalFilename   string                   `db:"original_filename" json:"original_filename"`
	StoragePath        *string                  `db:"storage_path" json:"storage_path"`
	MimeType           string                   `db:"mime_type" json:"mime_type"`
	FileSize           int64                    `db:"file_size" json:"file_size"`
	Hash               *string                  `db:"hash" json:"hash"`
	Width              *int32                   `db:"width" json:"width"`
	Height             *int32                   `db:"height" json:"height"`
	Duration           *float64                 `db:"duration" json:"duration"`
	UploadTime         pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime          pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted          *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt          pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata   dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating             *int32                   `db:"rating" json:"rating"`
	Liked              *bool                    `db:"liked" json:"liked"`
	RepositoryID       pgtype.UUID              `db:"repository_id" json:"repository_id"`
	Status             []byte                   `db:"status" json:"status"`
	Thumbnails         interface{}              `db:"thumbnails" json:"thumbnails"`
	Tags               interface{}              `db:"tags" json:"tags"`
	Albums             interface{}              `db:"albums" json:"albums"`
	SpeciesPredictions interface{}              `db:"species_predictions" json:"species_predictions"`
	OcrResult          interface{}              `db:"ocr_result" json:"ocr_result"`
	FaceResult         interface{}              `db:"face_result" json:"face_result"`
	Caption            interface{}              `db:"caption" json:"caption"`
}

func (q *Queries) GetAssetWithRelations(ctx context.Context, assetID pgtype.UUID) (GetAssetWithRelationsRow, error) {
	row := q.db.QueryRow(ctx, getAssetWithRelations, assetID)
	var i GetAssetWithRelationsRow
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.RepositoryID,
		&i.Status,
		&i.Thumbnails,
		&i.Tags,
		&i.Albums,
		&i.SpeciesPredictions,
		&i.OcrResult,
		&i.FaceResult,
		&i.Caption,
	)
	return i, err
}

const getAssetWithTags = `-- name: GetAssetWithTags :one
SELECT
    a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status,
    COALESCE(
        json_agg(
            json_build_object(
                'tag_id', tg.tag_id,
                'tag_name', tg.tag_name,
                'category', tg.category,
                'confidence', at.confidence,
                'source', at.source
            )
        ) FILTER (WHERE tg.tag_id IS NOT NULL),
        '[]'
    ) as tags
FROM assets a
LEFT JOIN asset_tags at ON a.asset_id = at.asset_id
LEFT JOIN tags tg ON at.tag_id = tg.tag_id
WHERE a.asset_id = $1 AND a.is_deleted = false
GROUP BY a.asset_id, a.rating, a.liked
`

type GetAssetWithTagsRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      *string                  `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating           *int32                   `db:"rating" json:"rating"`
	Liked            *bool                    `db:"liked" json:"liked"`
	RepositoryID     pgtype.UUID              `db:"repository_id" json:"repository_id"`
	Status           []byte                   `db:"status" json:"status"`
	Tags             interface{}              `db:"tags" json:"tags"`
}

func (q *Queries) GetAssetWithTags(ctx context.Context, assetID pgtype.UUID) (GetAssetWithTagsRow, error) {
	row := q.db.QueryRow(ctx, getAssetWithTags, assetID)
	var i GetAssetWithTagsRow
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.RepositoryID,
		&i.Status,
		&i.Tags,
	)
	return i, err
}

const getAssetWithThumbnails = `-- name: GetAssetWithThumbnails :one
SELECT
    a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status,
    COALESCE(
        json_agg(
            json_build_object(
                'thumbnail_id', t.thumbnail_id,
                'size', t.size,
                'storage_path', t.storage_path,
                'mime_type', t.mime_type,
                'created_at', t.created_at
            ) ORDER BY
            CASE t.size
                WHEN 'small' THEN 1
                WHEN 'medium' THEN 2
                WHEN 'large' THEN 3
            END
        ) FILTER (WHERE t.thumbnail_id IS NOT NULL),
        '[]'
    ) as thumbnails
FROM assets a
LEFT JOIN thumbnails t ON a.asset_id = t.asset_id
WHERE a.asset_id = $1 AND a.is_deleted = false
GROUP BY a.asset_id, a.rating, a.liked
`

type GetAssetWithThumbnailsRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      *string                  `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating           *int32                   `db:"rating" json:"rating"`
	Liked            *bool                    `db:"liked" json:"liked"`
	RepositoryID     pgtype.UUID              `db:"repository_id" json:"repository_id"`
	Status           []byte                   `db:"status" json:"status"`
	Thumbnails       interface{}              `db:"thumbnails" json:"thumbnails"`
}

func (q *Queries) GetAssetWithThumbnails(ctx context.Context, assetID pgtype.UUID) (GetAssetWithThumbnailsRow, error) {
	row := q.db.QueryRow(ctx, getAssetWithThumbnails, assetID)
	var i GetAssetWithThumbnailsRow
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.RepositoryID,
		&i.Status,
		&i.Thumbnails,
	)
	return i, err
}
