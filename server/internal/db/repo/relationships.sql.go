// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: relationships.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
	"server/internal/db/dbtypes"
)

const getAssetWithRelations = `-- name: GetAssetWithRelations :one
SELECT
    a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.embedding,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'thumbnail_id', t.thumbnail_id,
                'size', t.size,
                'storage_path', t.storage_path,
                'mime_type', t.mime_type
            )
        ) FILTER (WHERE t.thumbnail_id IS NOT NULL),
        '[]'
    ) as thumbnails,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'tag_id', tg.tag_id,
                'tag_name', tg.tag_name,
                'confidence', at.confidence
            )
        ) FILTER (WHERE tg.tag_id IS NOT NULL),
        '[]'
    ) as tags,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'album_id', al.album_id,
                'album_name', al.album_name,
                'position', aa.position,
                'added_time', aa.added_time
            )
        ) FILTER (WHERE al.album_id IS NOT NULL),
        '[]'
    ) as albums,
    COALESCE(
        json_agg(DISTINCT
            jsonb_build_object(
                'label', sp.label,
                'score', sp.score
            )
        ) FILTER (WHERE sp.label IS NOT NULL),
        '[]'
    ) as species_predictions
FROM assets a
LEFT JOIN thumbnails t ON a.asset_id = t.asset_id
LEFT JOIN asset_tags at ON a.asset_id = at.asset_id
LEFT JOIN tags tg ON at.tag_id = tg.tag_id
LEFT JOIN album_assets aa ON a.asset_id = aa.asset_id
LEFT JOIN albums al ON aa.album_id = al.album_id
LEFT JOIN species_predictions sp ON a.asset_id = sp.asset_id
WHERE a.asset_id = $1 AND a.is_deleted = false
GROUP BY a.asset_id, a.rating, a.liked
`

type GetAssetWithRelationsRow struct {
	AssetID            pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID            *int32                   `db:"owner_id" json:"owner_id"`
	Type               string                   `db:"type" json:"type"`
	OriginalFilename   string                   `db:"original_filename" json:"original_filename"`
	StoragePath        string                   `db:"storage_path" json:"storage_path"`
	MimeType           string                   `db:"mime_type" json:"mime_type"`
	FileSize           int64                    `db:"file_size" json:"file_size"`
	Hash               *string                  `db:"hash" json:"hash"`
	Width              *int32                   `db:"width" json:"width"`
	Height             *int32                   `db:"height" json:"height"`
	Duration           *float64                 `db:"duration" json:"duration"`
	UploadTime         pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime          pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted          *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt          pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata   dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating             *int32                   `db:"rating" json:"rating"`
	Liked              *bool                    `db:"liked" json:"liked"`
	Embedding          *pgvector_go.Vector      `db:"embedding" json:"embedding"`
	Thumbnails         interface{}              `db:"thumbnails" json:"thumbnails"`
	Tags               interface{}              `db:"tags" json:"tags"`
	Albums             interface{}              `db:"albums" json:"albums"`
	SpeciesPredictions interface{}              `db:"species_predictions" json:"species_predictions"`
}

func (q *Queries) GetAssetWithRelations(ctx context.Context, assetID pgtype.UUID) (GetAssetWithRelationsRow, error) {
	row := q.db.QueryRow(ctx, getAssetWithRelations, assetID)
	var i GetAssetWithRelationsRow
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.Embedding,
		&i.Thumbnails,
		&i.Tags,
		&i.Albums,
		&i.SpeciesPredictions,
	)
	return i, err
}

const getAssetWithTags = `-- name: GetAssetWithTags :one
SELECT
    a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.embedding,
    COALESCE(
        json_agg(
            json_build_object(
                'tag_id', tg.tag_id,
                'tag_name', tg.tag_name,
                'category', tg.category,
                'confidence', at.confidence,
                'source', at.source
            )
        ) FILTER (WHERE tg.tag_id IS NOT NULL),
        '[]'
    ) as tags
FROM assets a
LEFT JOIN asset_tags at ON a.asset_id = at.asset_id
LEFT JOIN tags tg ON at.tag_id = tg.tag_id
WHERE a.asset_id = $1 AND a.is_deleted = false
GROUP BY a.asset_id, a.rating, a.liked
`

type GetAssetWithTagsRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      string                   `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating           *int32                   `db:"rating" json:"rating"`
	Liked            *bool                    `db:"liked" json:"liked"`
	Embedding        *pgvector_go.Vector      `db:"embedding" json:"embedding"`
	Tags             interface{}              `db:"tags" json:"tags"`
}

func (q *Queries) GetAssetWithTags(ctx context.Context, assetID pgtype.UUID) (GetAssetWithTagsRow, error) {
	row := q.db.QueryRow(ctx, getAssetWithTags, assetID)
	var i GetAssetWithTagsRow
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.Embedding,
		&i.Tags,
	)
	return i, err
}

const getAssetWithThumbnails = `-- name: GetAssetWithThumbnails :one
SELECT
    a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.embedding,
    COALESCE(
        json_agg(
            json_build_object(
                'thumbnail_id', t.thumbnail_id,
                'size', t.size,
                'storage_path', t.storage_path,
                'mime_type', t.mime_type,
                'created_at', t.created_at
            ) ORDER BY
            CASE t.size
                WHEN 'small' THEN 1
                WHEN 'medium' THEN 2
                WHEN 'large' THEN 3
            END
        ) FILTER (WHERE t.thumbnail_id IS NOT NULL),
        '[]'
    ) as thumbnails
FROM assets a
LEFT JOIN thumbnails t ON a.asset_id = t.asset_id
WHERE a.asset_id = $1 AND a.is_deleted = false
GROUP BY a.asset_id, a.rating, a.liked
`

type GetAssetWithThumbnailsRow struct {
	AssetID          pgtype.UUID              `db:"asset_id" json:"asset_id"`
	OwnerID          *int32                   `db:"owner_id" json:"owner_id"`
	Type             string                   `db:"type" json:"type"`
	OriginalFilename string                   `db:"original_filename" json:"original_filename"`
	StoragePath      string                   `db:"storage_path" json:"storage_path"`
	MimeType         string                   `db:"mime_type" json:"mime_type"`
	FileSize         int64                    `db:"file_size" json:"file_size"`
	Hash             *string                  `db:"hash" json:"hash"`
	Width            *int32                   `db:"width" json:"width"`
	Height           *int32                   `db:"height" json:"height"`
	Duration         *float64                 `db:"duration" json:"duration"`
	UploadTime       pgtype.Timestamptz       `db:"upload_time" json:"upload_time"`
	TakenTime        pgtype.Timestamptz       `db:"taken_time" json:"taken_time"`
	IsDeleted        *bool                    `db:"is_deleted" json:"is_deleted"`
	DeletedAt        pgtype.Timestamptz       `db:"deleted_at" json:"deleted_at"`
	SpecificMetadata dbtypes.SpecificMetadata `db:"specific_metadata" json:"specific_metadata"`
	Rating           *int32                   `db:"rating" json:"rating"`
	Liked            *bool                    `db:"liked" json:"liked"`
	Embedding        *pgvector_go.Vector      `db:"embedding" json:"embedding"`
	Thumbnails       interface{}              `db:"thumbnails" json:"thumbnails"`
}

func (q *Queries) GetAssetWithThumbnails(ctx context.Context, assetID pgtype.UUID) (GetAssetWithThumbnailsRow, error) {
	row := q.db.QueryRow(ctx, getAssetWithThumbnails, assetID)
	var i GetAssetWithThumbnailsRow
	err := row.Scan(
		&i.AssetID,
		&i.OwnerID,
		&i.Type,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.MimeType,
		&i.FileSize,
		&i.Hash,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.UploadTime,
		&i.TakenTime,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.SpecificMetadata,
		&i.Rating,
		&i.Liked,
		&i.Embedding,
		&i.Thumbnails,
	)
	return i, err
}
