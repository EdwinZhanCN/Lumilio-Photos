// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ai_descriptions.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAIDescription = `-- name: CreateAIDescription :one
INSERT INTO ai_descriptions (asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at
`

type CreateAIDescriptionParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	ModelID          string      `db:"model_id" json:"model_id"`
	Description      string      `db:"description" json:"description"`
	Summary          *string     `db:"summary" json:"summary"`
	Confidence       *float32    `db:"confidence" json:"confidence"`
	TokensGenerated  *int32      `db:"tokens_generated" json:"tokens_generated"`
	ProcessingTimeMs *int32      `db:"processing_time_ms" json:"processing_time_ms"`
	PromptUsed       *string     `db:"prompt_used" json:"prompt_used"`
	FinishReason     *string     `db:"finish_reason" json:"finish_reason"`
}

func (q *Queries) CreateAIDescription(ctx context.Context, arg CreateAIDescriptionParams) (AiDescription, error) {
	row := q.db.QueryRow(ctx, createAIDescription,
		arg.AssetID,
		arg.ModelID,
		arg.Description,
		arg.Summary,
		arg.Confidence,
		arg.TokensGenerated,
		arg.ProcessingTimeMs,
		arg.PromptUsed,
		arg.FinishReason,
	)
	var i AiDescription
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.Description,
		&i.Summary,
		&i.Confidence,
		&i.TokensGenerated,
		&i.ProcessingTimeMs,
		&i.PromptUsed,
		&i.FinishReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAIDescriptionByAsset = `-- name: DeleteAIDescriptionByAsset :exec
DELETE FROM ai_descriptions WHERE asset_id = $1
`

func (q *Queries) DeleteAIDescriptionByAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAIDescriptionByAsset, assetID)
	return err
}

const getAIDescriptionByAsset = `-- name: GetAIDescriptionByAsset :one
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM ai_descriptions
WHERE asset_id = $1
`

func (q *Queries) GetAIDescriptionByAsset(ctx context.Context, assetID pgtype.UUID) (AiDescription, error) {
	row := q.db.QueryRow(ctx, getAIDescriptionByAsset, assetID)
	var i AiDescription
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.Description,
		&i.Summary,
		&i.Confidence,
		&i.TokensGenerated,
		&i.ProcessingTimeMs,
		&i.PromptUsed,
		&i.FinishReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAIDescriptionStatsByModel = `-- name: GetAIDescriptionStatsByModel :many
SELECT
    model_id,
    COUNT(*) as total_descriptions,
    AVG(tokens_generated) as avg_tokens,
    MIN(tokens_generated) as min_tokens,
    MAX(tokens_generated) as max_tokens,
    AVG(processing_time_ms) as avg_processing_time,
    MIN(processing_time_ms) as min_processing_time,
    MAX(processing_time_ms) as max_processing_time,
    AVG(confidence) as avg_confidence
FROM ai_descriptions
GROUP BY model_id
ORDER BY total_descriptions DESC
`

type GetAIDescriptionStatsByModelRow struct {
	ModelID           string      `db:"model_id" json:"model_id"`
	TotalDescriptions int64       `db:"total_descriptions" json:"total_descriptions"`
	AvgTokens         float64     `db:"avg_tokens" json:"avg_tokens"`
	MinTokens         interface{} `db:"min_tokens" json:"min_tokens"`
	MaxTokens         interface{} `db:"max_tokens" json:"max_tokens"`
	AvgProcessingTime float64     `db:"avg_processing_time" json:"avg_processing_time"`
	MinProcessingTime interface{} `db:"min_processing_time" json:"min_processing_time"`
	MaxProcessingTime interface{} `db:"max_processing_time" json:"max_processing_time"`
	AvgConfidence     float64     `db:"avg_confidence" json:"avg_confidence"`
}

func (q *Queries) GetAIDescriptionStatsByModel(ctx context.Context) ([]GetAIDescriptionStatsByModelRow, error) {
	rows, err := q.db.Query(ctx, getAIDescriptionStatsByModel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAIDescriptionStatsByModelRow
	for rows.Next() {
		var i GetAIDescriptionStatsByModelRow
		if err := rows.Scan(
			&i.ModelID,
			&i.TotalDescriptions,
			&i.AvgTokens,
			&i.MinTokens,
			&i.MaxTokens,
			&i.AvgProcessingTime,
			&i.MinProcessingTime,
			&i.MaxProcessingTime,
			&i.AvgConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAIDescriptionsByModel = `-- name: GetAIDescriptionsByModel :many
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM ai_descriptions
WHERE model_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAIDescriptionsByModelParams struct {
	ModelID string `db:"model_id" json:"model_id"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAIDescriptionsByModel(ctx context.Context, arg GetAIDescriptionsByModelParams) ([]AiDescription, error) {
	rows, err := q.db.Query(ctx, getAIDescriptionsByModel, arg.ModelID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiDescription
	for rows.Next() {
		var i AiDescription
		if err := rows.Scan(
			&i.AssetID,
			&i.ModelID,
			&i.Description,
			&i.Summary,
			&i.Confidence,
			&i.TokensGenerated,
			&i.ProcessingTimeMs,
			&i.PromptUsed,
			&i.FinishReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLongAIDescriptions = `-- name: GetLongAIDescriptions :many
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM ai_descriptions
WHERE LENGTH(description) > $1
ORDER BY LENGTH(description) DESC
LIMIT $2
`

type GetLongAIDescriptionsParams struct {
	Description string `db:"description" json:"description"`
	Limit       int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetLongAIDescriptions(ctx context.Context, arg GetLongAIDescriptionsParams) ([]AiDescription, error) {
	rows, err := q.db.Query(ctx, getLongAIDescriptions, arg.Description, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiDescription
	for rows.Next() {
		var i AiDescription
		if err := rows.Scan(
			&i.AssetID,
			&i.ModelID,
			&i.Description,
			&i.Summary,
			&i.Confidence,
			&i.TokensGenerated,
			&i.ProcessingTimeMs,
			&i.PromptUsed,
			&i.FinishReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopAIDescriptionsByTokens = `-- name: GetTopAIDescriptionsByTokens :many
SELECT asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at FROM ai_descriptions
ORDER BY tokens_generated DESC
LIMIT $1
`

func (q *Queries) GetTopAIDescriptionsByTokens(ctx context.Context, limit int32) ([]AiDescription, error) {
	rows, err := q.db.Query(ctx, getTopAIDescriptionsByTokens, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiDescription
	for rows.Next() {
		var i AiDescription
		if err := rows.Scan(
			&i.AssetID,
			&i.ModelID,
			&i.Description,
			&i.Summary,
			&i.Confidence,
			&i.TokensGenerated,
			&i.ProcessingTimeMs,
			&i.PromptUsed,
			&i.FinishReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByAIDescription = `-- name: SearchAssetsByAIDescription :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN ai_descriptions d ON a.asset_id = d.asset_id
WHERE to_tsvector('english', d.description) @@ plainto_tsquery('english', $1)
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByAIDescriptionParams struct {
	PlaintoTsquery string `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32  `db:"offset" json:"offset"`
	Limit          int32  `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsByAIDescription(ctx context.Context, arg SearchAssetsByAIDescriptionParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByAIDescription, arg.PlaintoTsquery, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByAIDescriptionWithConfidence = `-- name: SearchAssetsByAIDescriptionWithConfidence :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN ai_descriptions d ON a.asset_id = d.asset_id
WHERE to_tsvector('english', d.description) @@ plainto_tsquery('english', $1)
AND d.confidence >= $4
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByAIDescriptionWithConfidenceParams struct {
	PlaintoTsquery string   `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32    `db:"offset" json:"offset"`
	Limit          int32    `db:"limit" json:"limit"`
	Confidence     *float32 `db:"confidence" json:"confidence"`
}

func (q *Queries) SearchAssetsByAIDescriptionWithConfidence(ctx context.Context, arg SearchAssetsByAIDescriptionWithConfidenceParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByAIDescriptionWithConfidence,
		arg.PlaintoTsquery,
		arg.Offset,
		arg.Limit,
		arg.Confidence,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByAISummary = `-- name: SearchAssetsByAISummary :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN ai_descriptions d ON a.asset_id = d.asset_id
WHERE to_tsvector('english', d.summary) @@ plainto_tsquery('english', $1)
AND d.summary IS NOT NULL
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByAISummaryParams struct {
	PlaintoTsquery string `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32  `db:"offset" json:"offset"`
	Limit          int32  `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsByAISummary(ctx context.Context, arg SearchAssetsByAISummaryParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByAISummary, arg.PlaintoTsquery, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAIDescription = `-- name: UpdateAIDescription :one
UPDATE ai_descriptions
SET
    model_id = $2,
    description = $3,
    summary = $4,
    confidence = $5,
    tokens_generated = $6,
    processing_time_ms = $7,
    prompt_used = $8,
    finish_reason = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
RETURNING asset_id, model_id, description, summary, confidence, tokens_generated, processing_time_ms, prompt_used, finish_reason, created_at, updated_at
`

type UpdateAIDescriptionParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	ModelID          string      `db:"model_id" json:"model_id"`
	Description      string      `db:"description" json:"description"`
	Summary          *string     `db:"summary" json:"summary"`
	Confidence       *float32    `db:"confidence" json:"confidence"`
	TokensGenerated  *int32      `db:"tokens_generated" json:"tokens_generated"`
	ProcessingTimeMs *int32      `db:"processing_time_ms" json:"processing_time_ms"`
	PromptUsed       *string     `db:"prompt_used" json:"prompt_used"`
	FinishReason     *string     `db:"finish_reason" json:"finish_reason"`
}

func (q *Queries) UpdateAIDescription(ctx context.Context, arg UpdateAIDescriptionParams) (AiDescription, error) {
	row := q.db.QueryRow(ctx, updateAIDescription,
		arg.AssetID,
		arg.ModelID,
		arg.Description,
		arg.Summary,
		arg.Confidence,
		arg.TokensGenerated,
		arg.ProcessingTimeMs,
		arg.PromptUsed,
		arg.FinishReason,
	)
	var i AiDescription
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.Description,
		&i.Summary,
		&i.Confidence,
		&i.TokensGenerated,
		&i.ProcessingTimeMs,
		&i.PromptUsed,
		&i.FinishReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAIDescriptionStats = `-- name: UpdateAIDescriptionStats :exec
UPDATE ai_descriptions
SET
    tokens_generated = (
        SELECT LENGTH(description) / 4.0 -- Approximate token count (rough estimate: 1 token â‰ˆ 4 characters)
        WHERE asset_id = $1
    )
WHERE asset_id = $1
`

func (q *Queries) UpdateAIDescriptionStats(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateAIDescriptionStats, assetID)
	return err
}
