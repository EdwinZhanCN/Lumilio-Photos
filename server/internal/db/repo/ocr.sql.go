// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ocr.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOCRResult = `-- name: CreateOCRResult :one
INSERT INTO ocr_results (asset_id, model_id, total_count, processing_time_ms)
VALUES ($1, $2, $3, $4)
RETURNING asset_id, model_id, total_count, processing_time_ms, created_at, updated_at
`

type CreateOCRResultParams struct {
	AssetID          pgtype.UUID `db:"asset_id" json:"asset_id"`
	ModelID          string      `db:"model_id" json:"model_id"`
	TotalCount       int32       `db:"total_count" json:"total_count"`
	ProcessingTimeMs *int32      `db:"processing_time_ms" json:"processing_time_ms"`
}

func (q *Queries) CreateOCRResult(ctx context.Context, arg CreateOCRResultParams) (OcrResult, error) {
	row := q.db.QueryRow(ctx, createOCRResult,
		arg.AssetID,
		arg.ModelID,
		arg.TotalCount,
		arg.ProcessingTimeMs,
	)
	var i OcrResult
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.TotalCount,
		&i.ProcessingTimeMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOCRTextItem = `-- name: CreateOCRTextItem :one
INSERT INTO ocr_text_items (asset_id, text_content, confidence, bounding_box, text_length, area_pixels)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, asset_id, text_content, confidence, bounding_box, text_length, area_pixels, created_at
`

type CreateOCRTextItemParams struct {
	AssetID     pgtype.UUID `db:"asset_id" json:"asset_id"`
	TextContent string      `db:"text_content" json:"text_content"`
	Confidence  float32     `db:"confidence" json:"confidence"`
	BoundingBox []byte      `db:"bounding_box" json:"bounding_box"`
	TextLength  int32       `db:"text_length" json:"text_length"`
	AreaPixels  *float32    `db:"area_pixels" json:"area_pixels"`
}

func (q *Queries) CreateOCRTextItem(ctx context.Context, arg CreateOCRTextItemParams) (OcrTextItem, error) {
	row := q.db.QueryRow(ctx, createOCRTextItem,
		arg.AssetID,
		arg.TextContent,
		arg.Confidence,
		arg.BoundingBox,
		arg.TextLength,
		arg.AreaPixels,
	)
	var i OcrTextItem
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.TextContent,
		&i.Confidence,
		&i.BoundingBox,
		&i.TextLength,
		&i.AreaPixels,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOCRResultByAsset = `-- name: DeleteOCRResultByAsset :exec
DELETE FROM ocr_results WHERE asset_id = $1
`

func (q *Queries) DeleteOCRResultByAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOCRResultByAsset, assetID)
	return err
}

const deleteOCRTextItemsByAsset = `-- name: DeleteOCRTextItemsByAsset :exec
DELETE FROM ocr_text_items WHERE asset_id = $1
`

func (q *Queries) DeleteOCRTextItemsByAsset(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOCRTextItemsByAsset, assetID)
	return err
}

const getHighConfidenceTextItems = `-- name: GetHighConfidenceTextItems :many
SELECT id, asset_id, text_content, confidence, bounding_box, text_length, area_pixels, created_at FROM ocr_text_items
WHERE confidence >= $1
ORDER BY confidence DESC, text_length DESC
LIMIT $2
`

type GetHighConfidenceTextItemsParams struct {
	Confidence float32 `db:"confidence" json:"confidence"`
	Limit      int32   `db:"limit" json:"limit"`
}

func (q *Queries) GetHighConfidenceTextItems(ctx context.Context, arg GetHighConfidenceTextItemsParams) ([]OcrTextItem, error) {
	rows, err := q.db.Query(ctx, getHighConfidenceTextItems, arg.Confidence, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OcrTextItem
	for rows.Next() {
		var i OcrTextItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.TextContent,
			&i.Confidence,
			&i.BoundingBox,
			&i.TextLength,
			&i.AreaPixels,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOCRResultByAsset = `-- name: GetOCRResultByAsset :one
SELECT asset_id, model_id, total_count, processing_time_ms, created_at, updated_at FROM ocr_results
WHERE asset_id = $1
`

func (q *Queries) GetOCRResultByAsset(ctx context.Context, assetID pgtype.UUID) (OcrResult, error) {
	row := q.db.QueryRow(ctx, getOCRResultByAsset, assetID)
	var i OcrResult
	err := row.Scan(
		&i.AssetID,
		&i.ModelID,
		&i.TotalCount,
		&i.ProcessingTimeMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOCRStatsByModel = `-- name: GetOCRStatsByModel :many
SELECT
    model_id,
    COUNT(*) as total_assets,
    SUM(total_count) as total_text_items,
    AVG(total_count) as avg_items_per_asset,
    MIN(processing_time_ms) as min_processing_time,
    MAX(processing_time_ms) as max_processing_time,
    AVG(processing_time_ms) as avg_processing_time
FROM ocr_results
GROUP BY model_id
ORDER BY total_assets DESC
`

type GetOCRStatsByModelRow struct {
	ModelID           string      `db:"model_id" json:"model_id"`
	TotalAssets       int64       `db:"total_assets" json:"total_assets"`
	TotalTextItems    int64       `db:"total_text_items" json:"total_text_items"`
	AvgItemsPerAsset  float64     `db:"avg_items_per_asset" json:"avg_items_per_asset"`
	MinProcessingTime interface{} `db:"min_processing_time" json:"min_processing_time"`
	MaxProcessingTime interface{} `db:"max_processing_time" json:"max_processing_time"`
	AvgProcessingTime float64     `db:"avg_processing_time" json:"avg_processing_time"`
}

func (q *Queries) GetOCRStatsByModel(ctx context.Context) ([]GetOCRStatsByModelRow, error) {
	rows, err := q.db.Query(ctx, getOCRStatsByModel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOCRStatsByModelRow
	for rows.Next() {
		var i GetOCRStatsByModelRow
		if err := rows.Scan(
			&i.ModelID,
			&i.TotalAssets,
			&i.TotalTextItems,
			&i.AvgItemsPerAsset,
			&i.MinProcessingTime,
			&i.MaxProcessingTime,
			&i.AvgProcessingTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOCRTextItemStatsByAsset = `-- name: GetOCRTextItemStatsByAsset :one
SELECT
    COUNT(*) as total_items,
    AVG(confidence) as avg_confidence,
    MIN(confidence) as min_confidence,
    MAX(confidence) as max_confidence,
    SUM(text_length) as total_text_length,
    AVG(text_length) as avg_text_length
FROM ocr_text_items
WHERE asset_id = $1
`

type GetOCRTextItemStatsByAssetRow struct {
	TotalItems      int64       `db:"total_items" json:"total_items"`
	AvgConfidence   float64     `db:"avg_confidence" json:"avg_confidence"`
	MinConfidence   interface{} `db:"min_confidence" json:"min_confidence"`
	MaxConfidence   interface{} `db:"max_confidence" json:"max_confidence"`
	TotalTextLength int64       `db:"total_text_length" json:"total_text_length"`
	AvgTextLength   float64     `db:"avg_text_length" json:"avg_text_length"`
}

func (q *Queries) GetOCRTextItemStatsByAsset(ctx context.Context, assetID pgtype.UUID) (GetOCRTextItemStatsByAssetRow, error) {
	row := q.db.QueryRow(ctx, getOCRTextItemStatsByAsset, assetID)
	var i GetOCRTextItemStatsByAssetRow
	err := row.Scan(
		&i.TotalItems,
		&i.AvgConfidence,
		&i.MinConfidence,
		&i.MaxConfidence,
		&i.TotalTextLength,
		&i.AvgTextLength,
	)
	return i, err
}

const getOCRTextItemsByAsset = `-- name: GetOCRTextItemsByAsset :many
SELECT id, asset_id, text_content, confidence, bounding_box, text_length, area_pixels, created_at FROM ocr_text_items
WHERE asset_id = $1
ORDER BY confidence DESC, text_length DESC
`

func (q *Queries) GetOCRTextItemsByAsset(ctx context.Context, assetID pgtype.UUID) ([]OcrTextItem, error) {
	rows, err := q.db.Query(ctx, getOCRTextItemsByAsset, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OcrTextItem
	for rows.Next() {
		var i OcrTextItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.TextContent,
			&i.Confidence,
			&i.BoundingBox,
			&i.TextLength,
			&i.AreaPixels,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOCRTextItemsByAssetWithLimit = `-- name: GetOCRTextItemsByAssetWithLimit :many
SELECT id, asset_id, text_content, confidence, bounding_box, text_length, area_pixels, created_at FROM ocr_text_items
WHERE asset_id = $1
ORDER BY confidence DESC, text_length DESC
LIMIT $2
`

type GetOCRTextItemsByAssetWithLimitParams struct {
	AssetID pgtype.UUID `db:"asset_id" json:"asset_id"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetOCRTextItemsByAssetWithLimit(ctx context.Context, arg GetOCRTextItemsByAssetWithLimitParams) ([]OcrTextItem, error) {
	rows, err := q.db.Query(ctx, getOCRTextItemsByAssetWithLimit, arg.AssetID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OcrTextItem
	for rows.Next() {
		var i OcrTextItem
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.TextContent,
			&i.Confidence,
			&i.BoundingBox,
			&i.TextLength,
			&i.AreaPixels,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByOCRText = `-- name: SearchAssetsByOCRText :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN ocr_results r ON a.asset_id = r.asset_id
JOIN ocr_text_items t ON r.asset_id = t.asset_id
WHERE to_tsvector('simple', t.text_content) @@ plainto_tsquery('simple', $1)
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByOCRTextParams struct {
	PlaintoTsquery string `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32  `db:"offset" json:"offset"`
	Limit          int32  `db:"limit" json:"limit"`
}

func (q *Queries) SearchAssetsByOCRText(ctx context.Context, arg SearchAssetsByOCRTextParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByOCRText, arg.PlaintoTsquery, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAssetsByOCRTextWithConfidence = `-- name: SearchAssetsByOCRTextWithConfidence :many
SELECT DISTINCT a.asset_id, a.owner_id, a.type, a.original_filename, a.storage_path, a.mime_type, a.file_size, a.hash, a.width, a.height, a.duration, a.upload_time, a.taken_time, a.is_deleted, a.deleted_at, a.specific_metadata, a.rating, a.liked, a.repository_id, a.status FROM assets a
JOIN ocr_results r ON a.asset_id = r.asset_id
JOIN ocr_text_items t ON r.asset_id = t.asset_id
WHERE to_tsvector('simple', t.text_content) @@ plainto_tsquery('simple', $1)
AND t.confidence >= $4
ORDER BY a.upload_time DESC
LIMIT $3 OFFSET $2
`

type SearchAssetsByOCRTextWithConfidenceParams struct {
	PlaintoTsquery string  `db:"plainto_tsquery" json:"plainto_tsquery"`
	Offset         int32   `db:"offset" json:"offset"`
	Limit          int32   `db:"limit" json:"limit"`
	Confidence     float32 `db:"confidence" json:"confidence"`
}

func (q *Queries) SearchAssetsByOCRTextWithConfidence(ctx context.Context, arg SearchAssetsByOCRTextWithConfidenceParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, searchAssetsByOCRTextWithConfidence,
		arg.PlaintoTsquery,
		arg.Offset,
		arg.Limit,
		arg.Confidence,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.OwnerID,
			&i.Type,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.MimeType,
			&i.FileSize,
			&i.Hash,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.UploadTime,
			&i.TakenTime,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.SpecificMetadata,
			&i.Rating,
			&i.Liked,
			&i.RepositoryID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOCRResultStats = `-- name: UpdateOCRResultStats :exec
UPDATE ocr_results
SET total_count = (
    SELECT COUNT(*) FROM ocr_text_items ti WHERE ti.asset_id = $1
),
updated_at = CURRENT_TIMESTAMP
WHERE asset_id = $1
`

func (q *Queries) UpdateOCRResultStats(ctx context.Context, assetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateOCRResultStats, assetID)
	return err
}
