// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: embeddings.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const getAssetEmbedding = `-- name: GetAssetEmbedding :one
SELECT asset_id, embedding
FROM assets
WHERE asset_id = $1 AND embedding IS NOT NULL
`

type GetAssetEmbeddingRow struct {
	AssetID   pgtype.UUID        `db:"asset_id" json:"asset_id"`
	Embedding pgvector_go.Vector `db:"embedding" json:"embedding"`
}

func (q *Queries) GetAssetEmbedding(ctx context.Context, assetID pgtype.UUID) (GetAssetEmbeddingRow, error) {
	row := q.db.QueryRow(ctx, getAssetEmbedding, assetID)
	var i GetAssetEmbeddingRow
	err := row.Scan(&i.AssetID, &i.Embedding)
	return i, err
}

const getAssetsWithEmbeddings = `-- name: GetAssetsWithEmbeddings :many
SELECT asset_id, embedding
FROM assets
WHERE embedding IS NOT NULL
  AND is_deleted = false
ORDER BY upload_time DESC
LIMIT $1 OFFSET $2
`

type GetAssetsWithEmbeddingsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type GetAssetsWithEmbeddingsRow struct {
	AssetID   pgtype.UUID        `db:"asset_id" json:"asset_id"`
	Embedding pgvector_go.Vector `db:"embedding" json:"embedding"`
}

func (q *Queries) GetAssetsWithEmbeddings(ctx context.Context, arg GetAssetsWithEmbeddingsParams) ([]GetAssetsWithEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, getAssetsWithEmbeddings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetsWithEmbeddingsRow
	for rows.Next() {
		var i GetAssetsWithEmbeddingsRow
		if err := rows.Scan(&i.AssetID, &i.Embedding); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchNearestAssets = `-- name: SearchNearestAssets :many
SELECT asset_id, (embedding <-> $1::vector) AS distance
FROM assets
WHERE embedding IS NOT NULL
  AND is_deleted = false
ORDER BY (embedding <-> $1::vector)
LIMIT $2
`

type SearchNearestAssetsParams struct {
	Column1 pgvector_go.Vector `db:"column_1" json:"column_1"`
	Limit   int32              `db:"limit" json:"limit"`
}

type SearchNearestAssetsRow struct {
	AssetID  pgtype.UUID `db:"asset_id" json:"asset_id"`
	Distance interface{} `db:"distance" json:"distance"`
}

func (q *Queries) SearchNearestAssets(ctx context.Context, arg SearchNearestAssetsParams) ([]SearchNearestAssetsRow, error) {
	rows, err := q.db.Query(ctx, searchNearestAssets, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchNearestAssetsRow
	for rows.Next() {
		var i SearchNearestAssetsRow
		if err := rows.Scan(&i.AssetID, &i.Distance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEmbedding = `-- name: UpsertEmbedding :exec
UPDATE assets
SET embedding = $2
WHERE asset_id = $1
`

type UpsertEmbeddingParams struct {
	AssetID   pgtype.UUID        `db:"asset_id" json:"asset_id"`
	Embedding pgvector_go.Vector `db:"embedding" json:"embedding"`
}

func (q *Queries) UpsertEmbedding(ctx context.Context, arg UpsertEmbeddingParams) error {
	_, err := q.db.Exec(ctx, upsertEmbedding, arg.AssetID, arg.Embedding)
	return err
}
