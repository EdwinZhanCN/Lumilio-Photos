// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: repositories.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRepositories = `-- name: CountRepositories :one
SELECT COUNT(*) FROM repositories
`

func (q *Queries) CountRepositories(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRepositories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRepositoriesByStatus = `-- name: CountRepositoriesByStatus :one
SELECT COUNT(*) FROM repositories
WHERE status = $1
`

func (q *Queries) CountRepositoriesByStatus(ctx context.Context, status *string) (int64, error) {
	row := q.db.QueryRow(ctx, countRepositoriesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRepository = `-- name: CreateRepository :one
INSERT INTO repositories (
    repo_id,
    name,
    path,
    config,
    status,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING repo_id, name, path, config, status, last_sync, created_at, updated_at
`

type CreateRepositoryParams struct {
	RepoID    pgtype.UUID        `db:"repo_id" json:"repo_id"`
	Name      string             `db:"name" json:"name"`
	Path      string             `db:"path" json:"path"`
	Config    []byte             `db:"config" json:"config"`
	Status    *string            `db:"status" json:"status"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateRepository(ctx context.Context, arg CreateRepositoryParams) (Repository, error) {
	row := q.db.QueryRow(ctx, createRepository,
		arg.RepoID,
		arg.Name,
		arg.Path,
		arg.Config,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Repository
	err := row.Scan(
		&i.RepoID,
		&i.Name,
		&i.Path,
		&i.Config,
		&i.Status,
		&i.LastSync,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRepositories = `-- name: DeleteRepositories :exec
DELETE FROM repositories
WHERE repo_id = ANY($1::uuid[])
`

func (q *Queries) DeleteRepositories(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRepositories, dollar_1)
	return err
}

const deleteRepository = `-- name: DeleteRepository :exec
DELETE FROM repositories
WHERE repo_id = $1
`

func (q *Queries) DeleteRepository(ctx context.Context, repoID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRepository, repoID)
	return err
}

const getRepository = `-- name: GetRepository :one
SELECT repo_id, name, path, config, status, last_sync, created_at, updated_at FROM repositories
WHERE repo_id = $1
`

func (q *Queries) GetRepository(ctx context.Context, repoID pgtype.UUID) (Repository, error) {
	row := q.db.QueryRow(ctx, getRepository, repoID)
	var i Repository
	err := row.Scan(
		&i.RepoID,
		&i.Name,
		&i.Path,
		&i.Config,
		&i.Status,
		&i.LastSync,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRepositoryByPath = `-- name: GetRepositoryByPath :one
SELECT repo_id, name, path, config, status, last_sync, created_at, updated_at FROM repositories
WHERE path = $1
`

func (q *Queries) GetRepositoryByPath(ctx context.Context, path string) (Repository, error) {
	row := q.db.QueryRow(ctx, getRepositoryByPath, path)
	var i Repository
	err := row.Scan(
		&i.RepoID,
		&i.Name,
		&i.Path,
		&i.Config,
		&i.Status,
		&i.LastSync,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveRepositories = `-- name: ListActiveRepositories :many
SELECT repo_id, name, path, config, status, last_sync, created_at, updated_at FROM repositories
WHERE status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) ListActiveRepositories(ctx context.Context) ([]Repository, error) {
	rows, err := q.db.Query(ctx, listActiveRepositories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.RepoID,
			&i.Name,
			&i.Path,
			&i.Config,
			&i.Status,
			&i.LastSync,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepositories = `-- name: ListRepositories :many
SELECT repo_id, name, path, config, status, last_sync, created_at, updated_at FROM repositories
ORDER BY created_at DESC
`

func (q *Queries) ListRepositories(ctx context.Context) ([]Repository, error) {
	rows, err := q.db.Query(ctx, listRepositories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.RepoID,
			&i.Name,
			&i.Path,
			&i.Config,
			&i.Status,
			&i.LastSync,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const repositoryExists = `-- name: RepositoryExists :one
SELECT EXISTS(
    SELECT 1 FROM repositories
    WHERE path = $1
)
`

func (q *Queries) RepositoryExists(ctx context.Context, path string) (bool, error) {
	row := q.db.QueryRow(ctx, repositoryExists, path)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateRepository = `-- name: UpdateRepository :one
UPDATE repositories
SET
    name = $2,
    config = $3,
    status = $4,
    updated_at = $5
WHERE repo_id = $1
RETURNING repo_id, name, path, config, status, last_sync, created_at, updated_at
`

type UpdateRepositoryParams struct {
	RepoID    pgtype.UUID        `db:"repo_id" json:"repo_id"`
	Name      string             `db:"name" json:"name"`
	Config    []byte             `db:"config" json:"config"`
	Status    *string            `db:"status" json:"status"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateRepository(ctx context.Context, arg UpdateRepositoryParams) (Repository, error) {
	row := q.db.QueryRow(ctx, updateRepository,
		arg.RepoID,
		arg.Name,
		arg.Config,
		arg.Status,
		arg.UpdatedAt,
	)
	var i Repository
	err := row.Scan(
		&i.RepoID,
		&i.Name,
		&i.Path,
		&i.Config,
		&i.Status,
		&i.LastSync,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRepositoryLastSync = `-- name: UpdateRepositoryLastSync :one
UPDATE repositories
SET
    last_sync = $2,
    updated_at = $3
WHERE repo_id = $1
RETURNING repo_id, name, path, config, status, last_sync, created_at, updated_at
`

type UpdateRepositoryLastSyncParams struct {
	RepoID    pgtype.UUID        `db:"repo_id" json:"repo_id"`
	LastSync  pgtype.Timestamptz `db:"last_sync" json:"last_sync"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateRepositoryLastSync(ctx context.Context, arg UpdateRepositoryLastSyncParams) (Repository, error) {
	row := q.db.QueryRow(ctx, updateRepositoryLastSync, arg.RepoID, arg.LastSync, arg.UpdatedAt)
	var i Repository
	err := row.Scan(
		&i.RepoID,
		&i.Name,
		&i.Path,
		&i.Config,
		&i.Status,
		&i.LastSync,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRepositoryStatus = `-- name: UpdateRepositoryStatus :one
UPDATE repositories
SET
    status = $2,
    updated_at = $3
WHERE repo_id = $1
RETURNING repo_id, name, path, config, status, last_sync, created_at, updated_at
`

type UpdateRepositoryStatusParams struct {
	RepoID    pgtype.UUID        `db:"repo_id" json:"repo_id"`
	Status    *string            `db:"status" json:"status"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateRepositoryStatus(ctx context.Context, arg UpdateRepositoryStatusParams) (Repository, error) {
	row := q.db.QueryRow(ctx, updateRepositoryStatus, arg.RepoID, arg.Status, arg.UpdatedAt)
	var i Repository
	err := row.Scan(
		&i.RepoID,
		&i.Name,
		&i.Path,
		&i.Config,
		&i.Status,
		&i.LastSync,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
